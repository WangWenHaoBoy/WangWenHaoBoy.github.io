{"meta":{"title":"Java博客","subtitle":"记录自己每一个脚印","description":"我的个人站，主要涉及前后端端知识共享、实践教程、前沿技术共同学习等方面","author":"王文昊","url":"https://javazhan.com"},"pages":[{"title":"categories","date":"2018-11-12T10:09:35.853Z","updated":"2018-11-09T08:20:36.000Z","comments":false,"path":"categories/index.html","permalink":"https://javazhan.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-01-31T14:10:28.000Z","updated":"2018-11-11T13:18:08.000Z","comments":true,"path":"about/index.html","permalink":"https://javazhan.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-12T10:09:35.862Z","updated":"2018-11-09T08:20:20.000Z","comments":false,"path":"tags/index.html","permalink":"https://javazhan.com/tags/index.html","excerpt":"","text":""},{"title":"留言","date":"2016-02-01T12:29:57.000Z","updated":"2018-11-09T13:55:04.000Z","comments":true,"path":"comment/index.html","permalink":"https://javazhan.com/comment/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot系列之springboot整合mybatis","slug":"2018-11-28-2-java-springboot-mybatis-1","date":"2018-11-20T16:00:00.000Z","updated":"2018-11-28T06:00:28.000Z","comments":true,"path":"2018/11/21/2018-11-28-2-java-springboot-mybatis-1/","link":"","permalink":"https://javazhan.com/2018/11/21/2018-11-28-2-java-springboot-mybatis-1/","excerpt":"","text":"添加依赖123456789101112&lt;!--mybatis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--jdbc依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 创建配置文件application.yml在src/main/source目录下创建配置文件application.yml配置内容为：12345678910111213#配置访问端口server: port: 8082#配置数据库spring: datasource: url: jdbc:mysql://localhost:3306/test driver-class-name: com.mysql.jdbc.Driver username: root password: root#配置mybatis *Mapper.xml的位置mybatis: mapper-locations: classpath:mapper/*Mapper.xml Student实体类1234567891011121314151617public class Student &#123; private String id; private String name; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; StudentDao接口1234@Mapperpublic interface StudentDao &#123; List&lt;Student&gt; listStudent();&#125; StudentDao接口对应的studentMapper.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wangwenhao.ssm.student.dao.StudentDao&quot;&gt; &lt;select id=&quot;listStudent&quot; resultType=&quot;com.wangwenhao.ssm.student.entity.Student&quot;&gt; select * from t_student &lt;/select&gt;&lt;/mapper&gt; StudentService服务类12345678@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public List&lt;Student&gt; listStudent()&#123; return studentDao.listStudent(); &#125;&#125; StudentService控制类1234567891011@Controller@RequestMapping(&quot;student&quot;)public class StudentController &#123; @Autowired private StudentService studentService; @RequestMapping(value=&quot;view&quot;,method=RequestMethod.GET) @ResponseBody public List&lt;Student&gt; viewStudent() &#123; return studentService.listStudent(); &#125;&#125; 启动启动类后访问http://localhost:8082/student/view显示结果为：1234567891011121314[ &#123; &quot;id&quot;: &quot;111&quot;, &quot;name&quot;: &quot;wang&quot; &#125;, &#123; &quot;id&quot;: &quot;222&quot;, &quot;name&quot;: &quot;wen&quot; &#125;, &#123; &quot;id&quot;: &quot;333&quot;, &quot;name&quot;: &quot;hao&quot; &#125;] 对应的是数据库的三条数据","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"springboot整合","slug":"springboot整合","permalink":"https://javazhan.com/tags/springboot整合/"}]},{"title":"springboot系列之springboot的创建","slug":"2018-11-28-1-java-springboot-1","date":"2018-11-20T16:00:00.000Z","updated":"2018-11-28T05:37:52.000Z","comments":true,"path":"2018/11/21/2018-11-28-1-java-springboot-1/","link":"","permalink":"https://javazhan.com/2018/11/21/2018-11-28-1-java-springboot-1/","excerpt":"","text":"创建一个简单的maven项目添加在pom.xml添加springboot依赖springboot版本为 2.0.6.RELEASE1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建一个启动类123456@SpringBootApplicationpublic class SSMArchitecturetApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SSMArchitecturetApplication.class, args); &#125;&#125; 创建一个Student实体类1234567891011121314151617public class Student &#123; private String id; private String name; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 创建一个控制类123456789101112@Controller@RequestMapping(&quot;student&quot;)public class StudentController &#123; @RequestMapping(value=&quot;view&quot;,method=RequestMethod.GET) @ResponseBody public Student viewStudent() &#123; Student student = new Student(); student.setId(&quot;one&quot;); student.setName(&quot;wangwenhao&quot;); return student; &#125;&#125; 启动启动类然后访问http://localhost:8080/student/view，返回结果为一个student的json值:{ “id”: “one”, “name”: “wangwenhao”} 到这里一个基本的springboot框架就已经搭建好了。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"springboot整合","slug":"springboot整合","permalink":"https://javazhan.com/tags/springboot整合/"}]},{"title":"java正则表达式之前瞻后顾","slug":"2018-11-21-1-java-regular-expression-1","date":"2018-11-20T16:00:00.000Z","updated":"2018-11-21T07:22:52.000Z","comments":true,"path":"2018/11/21/2018-11-21-1-java-regular-expression-1/","link":"","permalink":"https://javazhan.com/2018/11/21/2018-11-21-1-java-regular-expression-1/","excerpt":"","text":"概述 正则表达式的先行断言和后行断言一共有4种形式 (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion) (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion) (?&lt;=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion) (?&lt;!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion) 这里面的pattern是一个正则表达式。如同^代表开头，$代表结尾，\\b代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为“零宽”。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。 举例 下面分别举例来说明这4种断言的含义 (?=pattern) 正向先行断言代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。例如对”a regular expression”这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用”re(?=gular)”，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为”re(?=gular).”，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。 (?!pattern) 负向先行断言代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。例如对”regex represents regular expression”这个字符串，要想匹配除regex和regular之外的re，可以用”re(?!g)”，该表达式限定了re右边的位置，这个位置后面不是字符g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。 (?&lt;=pattern) 正向后行断言代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。例如对”regex represents regular expression”这个字符串，有4个单词，要想匹配单词内部的re，但不匹配单词开头的re，可以用”(?&lt;=\\w)re”，单词内部的re，在re前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。 (?&lt;!pattern) 负向后行断言代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。例如对”regex represents regular expression”这个字符串，要想匹配单词开头的re，可以用”(?&lt;!\\w)re”。单词开头的re，在本例中，也就是指不在单词内部的re，即re前面不是单词字符。当然也可以用”\\bre”来匹配。 注意 上述4种断言，括号里的pattern本身是一个正则表达式。但对2种后行断言有所限制，在Perl和Python中，这个表达式必须是定长(fixed length)的，即不能使用、+、?等元字符，如(?&lt;=abc)没有问题，但(?&lt;=abc)是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持?、{m}、{n,m}等符号，但同样不支持*、+字符。JavaScript干脆不支持后行断言，不过一般来说，这不是太大的问题。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"java设计模式之装饰者模式","slug":"2018-11-19-1-java-design-pattern-1","date":"2018-11-18T16:00:00.000Z","updated":"2018-11-19T02:00:30.000Z","comments":true,"path":"2018/11/19/2018-11-19-1-java-design-pattern-1/","link":"","permalink":"https://javazhan.com/2018/11/19/2018-11-19-1-java-design-pattern-1/","excerpt":"","text":"装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 概述这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 意图 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用 在不想增加很多子类的情况下扩展类。 如何解决 将具体功能职责划分，同时继承装饰者模式。 注意事项 可以替代继承 UML结构图 实现图形接口：123public interface Shape &#123; public void draw();&#125; 长方形类：1234567public class Rectangle implements Shape&#123; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot;drawShape:&quot;+this.getClass().getSimpleName()); &#125;&#125; 圆形类1234567public class Circle implements Shape &#123; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot;drawShape:&quot;+this.getClass().getSimpleName()); &#125;&#125; 装饰者接口：1234567public abstract class Decorate &#123; protected Shape shape; public Decorate(Shape shape) &#123; this.shape = shape; &#125; public abstract void draw();&#125; 装饰者实现类：1234567891011public class ConcreteDecorate extends Decorate &#123; public ConcreteDecorate(Shape shape) &#123; super(shape); // TODO Auto-generated constructor stub &#125; @Override public void draw() &#123; System.out.println(&quot;setBorder for &quot;+shape.getClass().getSimpleName()); shape.draw(); &#125;&#125; 测试类：12345678public class Test &#123; public static void main(String[] args) &#123; Decorate d = new ConcreteDecorate(new Rectangle()); d.draw(); d = new ConcreteDecorate(new Circle()); d.draw(); &#125;&#125; 输出结果：setBorder for RectangledrawShape:RectanglesetBorder for CircledrawShape:Circle 总结 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点： 多层装饰比较复杂。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"https://javazhan.com/tags/java设计模式/"}]},{"title":"java设计模式之观察者模式","slug":"2018-11-19-2-java-design-pattern-2","date":"2018-11-18T16:00:00.000Z","updated":"2018-11-19T09:20:16.000Z","comments":true,"path":"2018/11/19/2018-11-19-2-java-design-pattern-2/","link":"","permalink":"https://javazhan.com/2018/11/19/2018-11-19-2-java-design-pattern-2/","excerpt":"","text":"当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 概念 意图 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 使用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 UML结构图 实现前台类：123456789101112131415161718192021222324public class Reception &#123; private int state; private List&lt;DepartMent&gt; departMentList=new ArrayList&lt;DepartMent&gt;(); public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; if(this.state==0) &#123; notifyAllStaff(&quot;老板来了&quot;); &#125;else &#123; notifyAllStaff(&quot;老板走了&quot;); &#125; &#125; public void attach(DepartMent staff) &#123; departMentList.add(staff); &#125; public void notifyAllStaff(String stateStr) &#123; for(DepartMent departMent : departMentList) &#123; departMent.update(stateStr); &#125; &#125;&#125; 部门抽象类：1234567public abstract class DepartMent &#123;protected Reception reception;public DepartMent(Reception reception) &#123; this.reception = reception;&#125;public abstract void update(String stateStr);&#125; 部门A：123456789101112public class DepartMentA extends DepartMent &#123; public DepartMentA(Reception reception) &#123; super(reception); this.reception.attach(this); // TODO Auto-generated constructor stub &#125; @Override public void update(String stateStr) &#123; // TODO Auto-generated method stub System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;); &#125;&#125; 部门B：123456789101112public class DepartMentB extends DepartMent &#123; public DepartMentB(Reception reception) &#123; super(reception); this.reception.attach(this); // TODO Auto-generated constructor stub &#125; @Override public void update(String stateStr) &#123; // TODO Auto-generated method stub System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;); &#125;&#125; 部门C：123456789101112public class DepartMentC extends DepartMent &#123; public DepartMentC(Reception reception) &#123; super(reception); this.reception.attach(this); // TODO Auto-generated constructor stub &#125; @Override public void update(String stateStr) &#123; // TODO Auto-generated method stub System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;); &#125;&#125; 测试类：12345678910public class Test &#123; public static void main(String[] args) &#123; Reception reception = new Reception(); new DepartMentA(reception); new DepartMentB(reception); new DepartMentC(reception); reception.setState(0); reception.setState(1); &#125;&#125; 输出结果为：DepartMentA接收到Reception通知,老板来了,改变工作状态DepartMentB接收到Reception通知,老板来了,改变工作状态DepartMentC接收到Reception通知,老板来了,改变工作状态DepartMentA接收到Reception通知,老板走了,改变工作状态DepartMentB接收到Reception通知,老板走了,改变工作状态DepartMentC接收到Reception通知,老板走了,改变工作状态 总结 优点 观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的被观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"https://javazhan.com/tags/java设计模式/"}]},{"title":"java设计模式之建造者模式","slug":"2018-11-19-3-java-design-pattern-3","date":"2018-11-18T16:00:00.000Z","updated":"2018-11-19T09:19:52.000Z","comments":true,"path":"2018/11/19/2018-11-19-3-java-design-pattern-3/","link":"","permalink":"https://javazhan.com/2018/11/19/2018-11-19-3-java-design-pattern-3/","excerpt":"","text":"建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 概述 意图 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决 主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用 一些基本部件不会变，而其组合经常变化的时候。 如何解决 将变与不变分离开。 注意事项 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，而工厂模式更加关注的是零件的类型。 UML结构图 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 Item物品抽象类：12345public abstract class Item &#123; public abstract String getName(); public abstract double getPrice(); public abstract Package getPack();&#125; Burger汉堡包抽象类123public abstract class Burger extends Item&#123;&#125; VegBurger蔬菜汉堡包类：1234567891011121314151617public class VegBurger extends Burger&#123; @Override public String getName() &#123; // TODO Auto-generated method stub return &quot;VegBurger&quot;; &#125; @Override public double getPrice() &#123; // TODO Auto-generated method stub return 30.6; &#125; @Override public Package getPack() &#123; // TODO Auto-generated method stub return new Wrapper(); &#125;&#125; ChickenBurger鸡肉汉堡吧：1234567891011121314151617public class ChickenBurger extends Burger &#123; @Override public String getName() &#123; // TODO Auto-generated method stub return &quot;ChickenBurger&quot;; &#125; @Override public double getPrice() &#123; // TODO Auto-generated method stub return 23.3; &#125; @Override public Package getPack() &#123; // TODO Auto-generated method stub return new Wrapper(); &#125;&#125; Drink饮料抽象类：123public abstract class Drink extends Item&#123;&#125; Coke可口可乐类：1234567891011121314151617public class Coke extends Drink&#123; @Override public String getName() &#123; // TODO Auto-generated method stub return &quot;Coke&quot;; &#125; @Override public double getPrice() &#123; // TODO Auto-generated method stub return 5.3; &#125; @Override public Package getPack() &#123; // TODO Auto-generated method stub return new Bottle(); &#125;&#125; Pepsi百事可乐类：1234567891011121314151617public class Pepsi extends Drink&#123; @Override public String getName() &#123; // TODO Auto-generated method stub return &quot;Pepsi&quot;; &#125; @Override public double getPrice() &#123; // TODO Auto-generated method stub return 3.0; &#125; @Override public Package getPack() &#123; // TODO Auto-generated method stub return new Bottle(); &#125;&#125; 包装接口类：123public interface Package &#123; public abstract String getName();&#125; 袋装类：123456public class Wrapper implements Package &#123; @Override public String getName() &#123; return &quot;Wrapper&quot;; &#125;&#125; 瓶装类：123456public class Bottle implements Package &#123; @Override public String getName() &#123; return &quot;Bottle&quot;; &#125;&#125; Meal类：123456789101112131415161718public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item) &#123; items.add(item); &#125; public void showTotalPrice() &#123; double price = 0; for(Item item : items) &#123; price+=item.getPrice(); &#125; System.out.println(price); &#125; public void showAllName() &#123; for(Item item : items) &#123; System.out.println(item.getName()); &#125; &#125;&#125; Meal构建类：1234567891011121314public class MealBuilder &#123; public Meal BuildMealOne() &#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal BuildMealTwo() &#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 测试类：1234567891011public class Test &#123; public static void main(String[] args) &#123; MealBuilder builder = new MealBuilder(); Meal mealone = builder.BuildMealOne(); mealone.showTotalPrice(); mealone.showAllName(); Meal mealtwo = builder.BuildMealTwo(); mealtwo.showTotalPrice(); mealtwo.showAllName(); &#125;&#125; 输出结果为：35.9VegBurgerCoke26.3ChickenBurgerPepsi 总结 优点 建造者独立，易扩展。 便于控制细节风险。 缺点 产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"https://javazhan.com/tags/java设计模式/"}]},{"title":"java设计模式之访问者模式","slug":"2018-11-17-1-java-design-pattern-1","date":"2018-11-16T16:00:00.000Z","updated":"2018-11-17T05:15:26.000Z","comments":true,"path":"2018/11/17/2018-11-17-1-java-design-pattern-1/","link":"","permalink":"https://javazhan.com/2018/11/17/2018-11-17-1-java-design-pattern-1/","excerpt":"","text":"访问者模式（Visitor Pattern）属于对象行为型模式的一种，表示一个作用于其对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 概述访问者模式： 预留通路，回调实现。它的实现主要就是通过预先定义好调用的通路，在被访问的对象上定义accept方法，在访问者的对象上定义visit方法；然后在调用真正发生的时候，通过两次分发的技术，利用预先定义好的通路，回调到访问者具体的实现上。 主要解决 现已稳定的数据结构和易变的操作耦合问题，把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。 UML结构图 模式结构 抽象访问者(Visitor)： 定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变（不能改变的意思是说，如果元素类的个数经常改变，则说明不适合使用访问者模式）。 具体访问者(ConcreteVisitor)： 给出对每一个元素类访问时所产生的具体行为。 抽象节点(Element)： 定义了一个接受访问者（accept）的方法，其意义是指，每一个元素都要可以被访问者访问。 具体节点(ConcreteElement)： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 结构对象角色(ObjectStructure)： 定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 案例场景：很多人都有养宠物的习惯，这里就以此为例 访问者角色：给宠物喂食的人 具体访问者角色：主人、其他人 抽象元素角色：动物抽象类 具体元素角色：宠物狗、宠物猫 结构对象角色：主人家 结构图如下: 1.创建抽象访问者接口 123456interface Person &#123; void feed(Cat cat); void feed(Dog dog);&#125; 2.创建不同的具体访问者角色 – 主人/其他人，同时实现 Person接口 12345678910111213141516171819202122232425class Owner implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;主人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;主人喂食狗&quot;); &#125;&#125;class Someone implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;其他人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;其他人喂食狗&quot;); &#125;&#125; 3.创建 抽象节点 – 宠物 1234interface Animal &#123; void accept(Person person);&#125; 4.创建实现Animal接口的 具体节点（元素） 123456789101112131415161718192021class Dog implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，汪汪汪！！！&quot;); &#125;&#125;/** * 具体节点（元素）角色 -- 宠物猫 */class Cat implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，喵喵喵！！！&quot;); &#125;&#125; 5.创建实现Animal接口的 具体节点（元素） 123456789101112131415161718class Home &#123; private List&lt;Animal&gt; nodeList = new ArrayList&lt;&gt;(); void action(Person person) &#123; for (Animal node : nodeList) &#123; node.accept(person); &#125; &#125; /** * 添加操作 * * @param animal 动物 */ void add(Animal animal) &#123; nodeList.add(animal); &#125;&#125; 6.创建客户端，用于测试 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); &#125;&#125; 7.运行结果为：主人喂食狗好好吃，汪汪汪！！！主人喂食猫好好吃，喵喵喵！！！其他人喂食狗好好吃，汪汪汪！！！其他人喂食猫好好吃，喵喵喵！！！ 总结访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。 优点 扩展性好： 在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 复用性好： 通过访问者来定义整个对象结构通用的功能，从而提高复用程度。 分离无关行为： 通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。 缺点 对象结构变化很困难： 不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。 破坏封装： 访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。 使用场景 数据结构稳定，作用于数据结构的操作经常变化的时候。 当一个数据结构中，一些元素类需要负责与其不相关的操作的时候，为了将这些操作分离出去，以减少这些元素类的职责时，可以使用访问者模式。 有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"https://javazhan.com/tags/java设计模式/"}]},{"title":"java设计模式之策略模式","slug":"2018-11-15-1-java-design-pattern-1","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T02:08:30.000Z","comments":true,"path":"2018/11/15/2018-11-15-1-java-design-pattern-1/","link":"","permalink":"https://javazhan.com/2018/11/15/2018-11-15-1-java-design-pattern-1/","excerpt":"","text":"在阎宏博士的《JAVA与模式》一书中开头是这样描述策略（Strategy）模式的：策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 策略模式的结构策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。 这个模式涉及到三个角色：环境(Context)角色：持有一个Strategy的引用。抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。代码分析环境(Context)角色:123456789public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void contextInterface() &#123; strategy.strategyInterface(); &#125;&#125;抽象策略(Strategy)角色:123public interface Strategy &#123; void strategyInterface();&#125;具体策略(ConcreteStrategy)角色12345678public class ConcreteStrategyA implements Strategy&#123; @Override public void strategyInterface() &#123; // TODO Auto-generated method stub System.out.println(&quot;do something A&quot;); &#125;&#125;12345678public class ConcreteStrategyB implements Strategy&#123; @Override public void strategyInterface() &#123; // TODO Auto-generated method stub System.out.println(&quot;do something B&quot;); &#125;&#125;12345678public class ConcreteStrategyC implements Strategy&#123; @Override public void strategyInterface() &#123; // TODO Auto-generated method stub System.out.println(&quot;do something C&quot;); &#125;&#125;使用场景假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。根据描述，折扣是根据以下的几个算法中的一个进行的：算法一：对初级会员没有折扣。算法二：对中级会员打9折。算法三：对高级会员打8折。使用策略模式来实现的结构图如下： 价格类123456789public class Price &#123; private MeberStrategy strategy; public Price(MeberStrategy strategy) &#123; this.strategy = strategy; &#125; public double quote(double bookPrice) &#123; return strategy.calsPrice(bookPrice); &#125;&#125; 抽象折扣类123public interface MeberStrategy &#123; double calsPrice(Double bookPrice);&#125; 初级会员折扣类12345678public class PrimaryMeberStrategy implements MeberStrategy&#123; @Override public double calsPrice(Double bookPrice) &#123; // TODO Auto-generated method stub return bookPrice; &#125;&#125; 中级会员折扣类12345678public class IntermediateMeberStrategy implements MeberStrategy&#123; @Override public double calsPrice(Double bookPrice) &#123; // TODO Auto-generated method stub return bookPrice*0.9; &#125; &#125; 高级会员折扣类12345678public class AdvanceMeberStrategy implements MeberStrategy&#123; @Override public double calsPrice(Double bookPrice) &#123; // TODO Auto-generated method stub return bookPrice*0.9; &#125;&#125; 客户端12345678public class Client &#123; public static void main(String[] args) &#123; MeberStrategy strategy = new IntermediateMeberStrategy(); Price price = new Price(strategy); double bookPrice = price.quote(12); System.out.println(&quot;图书的最终价格:&quot;+bookPrice); &#125;&#125; 从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。 认识策略模式策略模式的重心策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。算法的平等性策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。运行时策略的唯一性运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。公有的行为经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。这其实也是典型的将代码向继承等级结构的上方集中的标准做法。 策略模式的优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"https://javazhan.com/tags/java设计模式/"}]},{"title":"初识enum(枚举类型)","slug":"2018-11-13-4-java-enum-1","date":"2018-11-12T16:00:00.000Z","updated":"2018-12-05T15:07:05.449Z","comments":true,"path":"2018/11/13/2018-11-13-4-java-enum-1/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/","excerpt":"","text":"概述枚举类型即enum，它使得我们在需要群组并使用枚举类型集是，可以很方便的处理。 枚举定义方式123public enum Season&#123; SPRING,SUMMER,AUTUMN,WINTER&#125; 使用枚举使用enum，需要创建一个该类型的引用，并将其赋值给某个实例:123456public class UseEnum&#123; public static void main(String[] args)&#123; Season spring = Season.SPRING; System.out.println(spring); &#125;&#125; 输出结果为：SPRING 在你创建enum时，编译器会自动添加一些有用的特性。例如，他会创建toString()方法，以便你可以很方便的显示某个enum实例的名字，这正是上面的打印语句如何产生其输出的答案的原因。编译器还会为他创建一个ordinal()方法，用来表示某个特定的enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组:1234567public class Test&#123; public static void mian(String[] args)&#123; for(Seasan season:Season.values())&#123; System.out.println(season+&quot;,ordinal &quot;+season.ordinal()); &#125; &#125;&#125; 输出结果为:SPRING,ordinal 0SUMMER,ordinal 1AUTUMN,ordinal 2WINTER,ordinal 3 尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应的类时，产生了某种编译行为，因此在很大程度上，你可以将enum当作其他的任何类来处理。事实上，enum确实是类，并且具有自己的方法。enum有一个特别实用的特性，即他可以在switch语句中使用:12345678910111213141516171819202122232425public class TestUseToSwitch &#123; public static void say(Season season) &#123; switch(season) &#123; case SPRING: System.out.println(&quot;春天来了&quot;); break; case SUMMER: System.out.println(&quot;夏天来了&quot;); break; case AUTUMN: System.out.println(&quot;秋天来了&quot;); break; case WINTER: System.out.println(&quot;冬天来了&quot;); break; default: System.out.println(&quot;不知道是什么天气&quot;); break; &#125; &#125; public static void main(String[] args) &#123; TestUseToSwitch.say(Season.AUTUMN); &#125;&#125; 输出结果为:秋天来了","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 三：数组的初始化 )","slug":"2018-11-13-3-java-initial-3","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T09:21:18.000Z","comments":true,"path":"2018/11/13/2018-11-13-3-java-initial-3/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/","excerpt":"","text":"数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。 一位数组的初始化一维数组的声明：int[] arr;方括号也可以置于标识符后面：int arr[];两种格式的含义都一样的，没有什么区别，通常C,C++程序猿习惯用第二种写法，不过前一种更合理，java程序猿的话推荐使用第一种写法。一位数组的初始化,如果是int基本类型,并且知道其值和长度时：int[] arr = {1,3,5,7,9}shuint[] arr = new int[]{1,3,5,7,9}上面这个两个数组初始化方法是等价的，没有什么区别如果不知道数组的值和长度时，可以采用以下初始化方法：int[] arr = new int[20]上面的20表示数组初始化的一个大概长度;如果用java.util.Arrays中的toString(arr)方法对数组进行输出，输出结果为：[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 二维数组的初始化二维数组的声明：int[][] arr;方括号也可以置于标识符后面：int arr[][];二维数组的初始化，以int基本类型举例12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; //二维数组的初始化第一步 Integer[][] values = new Integer[3][];//只定义了二维数组的一维长度为3,二维长度可以不定义 //也可以是Integer[][] values = new Integer[2][4] 这样就定义了数组在二维上的长度为4 for(int i=0;i&lt;values.length;i++) &#123; values[i] = new Integer[4];//定义了二维长度为4 for(int j=0;j&lt;values[i].length;j++) &#123; values[i][j] = new Integer(i+j); &#125; &#125; for(int i=0;i&lt;values.length;i++) &#123; for(int j=0;j&lt;values[i].length;j++) &#123; System.out.print(values[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 可变参数列表在可变参数列表中可以放入与该可变的参数类型相同的数组，举例：123456789101112public class Test &#123; public static void printObject(Integer...values) &#123;//可变参数 for(Integer value:values) &#123; System.out.println(value.intValue()); &#125; &#125; public static void main(String[] args) &#123; Integer[] values = &#123;1,3,5,7,9&#125;; printObject(values);//可将数组传入到可变参数中 &#125;&#125; 但需注意的是，传入的数组必须是一个一维数组，如果传入的是二维数组，那么在编译过程中会报错。总结： 一维数组初始化有三种形式int[] arr = {1,3,5,7,9};int[] arr = new int[]{1,3,5,7,9};int[] arr = new int[20]; 二维数组初始化有两种方式int[][] arr = new int[3][4];int[][] arr = new int[3][];//二维长度在赋值一维时定义长度，例如 arr[0] = new int[4]此时定义二维长度为4 可变参数中可以传入装入的类型与可变参数类型相同的数组，单数组必须是一维数组","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 二：构造器的初始化 )","slug":"2018-11-13-2-java-initial-2","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T07:02:24.000Z","comments":true,"path":"2018/11/13/2018-11-13-2-java-initial-2/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/","excerpt":"","text":"可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：123456public class Counter()&#123; int i; public Count()&#123; i = 7; &#125;&#125; 那么i首先会被置0，然后变为7，对于所有基本类型和对象的引用，包括在定义时已经指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前对元素进行初始化————因为初始化早已得到了保证。 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。及时变量定义散布于方法定义之间或者之后，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。例如：123456789101112131415161718192021222324public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125;&#125;public class Animal &#123; private Dog dog = new Dog(1); public Animal() &#123; new Dog(2); &#125; private Dog dog1 = new Dog(3); public void printf() &#123; new Dog(4); &#125; private Dog dog2 = new Dog(5);&#125;public class Test &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.printf(); &#125;&#125; 输出结果为：Dog1Dog3Dog5Dog2Dog4 在Animal类中，故意把几个Dog对象定义散布到各处，以证明它们全都会在构造器或其他方法之前的得到初始化。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null。如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。静态初始化只有在必要时刻才会进行，如果既不创建类也不引用 类.静态成员变量或者静态成员方法，那么静态的成员变量永远不会被创建。初始化的顺序是先静态成员变量后”非静态”成员变量。 显示的静态初始化Java语序将多个静态初始化动作组织成一个特殊的”静态子句”(有时也叫作”静态块”),与其他静态初始化动作一样，这样的静态块也是只执行一次：档首次生成这个类的一个对象时或者首次访问属于那个类的静态数据成员时。1234567891011121314151617181920212223public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125; public void f() &#123; System.out.println(&quot;print&quot;); &#125;&#125;public class Animal &#123; public static Dog dog1; public static Dog dog2; static &#123; dog1 = new Dog(1); dog2 = new Dog(2); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Animal.dog1.f(); &#125;&#125; 输出结果为Dog1Dog2print 非静态实例初始化Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量，例如:1234567891011121314151617181920212223public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125;&#125;public class Animal &#123; public Dog dog1; public Dog dog2; public Animal()&#123; System.out.println(&quot;Initial Animal Constructor&quot;); &#125; &#123; dog1 = new Dog(1); dog2 = new Dog(2); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new Animal(); &#125;&#125; 输出结果为:Dog1Dog2Initial Animal Constructor从输出结果可以看出实例的初始化子句是在构造器之前执行的。 总结： 成员变量自动初始化的进行是无法阻止的，它将在构造器被调用之前发生。 成员变量的定义散布于方法定义之间或者之后，但无论如何它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。 static关键字不能应用于局部变量，因此它只能作用于域。 如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null，如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。 初始化的顺序是先静态成员变量后”非静态”成员变量。 当new一个类时初始化顺序为：静态数据初始化–&gt;非静态的成员变量初始化–&gt;构造器初始化","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 一：成员变量的初始化 )","slug":"2018-11-13-1-java-initial-1","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T03:43:26.000Z","comments":true,"path":"2018/11/13/2018-11-13-1-java-initial-1/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/","excerpt":"","text":"关于成员变量的初始化Java会尽力保证:所有变量在使用前都能得到恰当的初始化。如果是成员变量是基本类型，类的每个基本类型的成员变量保证都会有一个初始值，如果成员变量是一个非基本类型，那么它将被初始化成一个特殊值null。下面的程序可以验证这种情况，Dog是一个注意他们的输出:1234567891011121314151617181920212223public class InitialVars()&#123; private boolean t; private char c; private byte b; private short s; private int i; private long l; private float f; private double d; private String st; public void printVars()&#123; System.out.println(&quot;输出结果为:&quot;); System.out.println(&quot;boolean--&gt;&quot;+t); System.out.println(&quot;char--&gt;&quot;+c); System.out.println(&quot;byte--&gt;&quot;+b); System.out.println(&quot;short--&gt;&quot;+s); System.out.println(&quot;int--&gt;&quot;+i); System.out.println(&quot;long--&gt;&quot;+l); System.out.println(&quot;float--&gt;&quot;+f); System.out.println(&quot;double--&gt;&quot;+d); System.out.println(&quot;String--&gt;&quot;+st); &#125;&#125; 输出结果为:boolean–&gt;false;char–&gt;byte–&gt;0short–&gt;0int–&gt;0long–&gt;0float–&gt;0.0double–&gt;0.0String–&gt;null可见尽管是基本类型的数据成员的初始值没有给出，但他们确实有值(char值为0,所以为空白)，你可以直接使用这些基本类型的成员变量，而非基本类型的成员变量初始值为null,你必须重新new它才可以使用，这样至少不会冒”未初始化变量”的风险了。 指定初始化如果你想为某个变量赋初始值，该怎么做呢？有一种很直接的办法，就是在定义类变量的地方直接为其赋值。以下代码片段修改了InitialVars类成员变量的定义，直接提供了初值。1234567891011public class InitialVarsOne()&#123; private boolean t = true; private char c = &apos;x&apos;; private byte b = 47; private short s = 0xff; private int i = 999; private long l = 1; private float f = 3.14f; private double d = 3.1415936; private String st = new String();&#125; 你还可以通过调用方法来初始化成员变量,举个简单例子： 1234567public class InitialVarsTwo()&#123; private int i = initialInt(); public int initialInt()&#123; return 3; &#125;&#125; 同时调用的方法中还可以是参数，但是这些参数必须是初始化后的，举个例子:1234567public class InitialVarsThree()&#123; private int j = 3; private int i = initialInt(j); public int initialInt(int vlaue)&#123; return value; &#125;&#125; 上面这样是可以的，但是像下面这样就不可以了:1234567public class InitialVarsFour()&#123; private int i = initialInt(j); private int j = 3; public int initialInt(int vlaue)&#123; return value; &#125;&#125; 此时初始化i的时候j还没有被初始化，所以编译会报错。显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以编译器恰当的对”向前引用”发出了警告。 对于方法中的局部变量,Java以编译时错误的形式来贯彻这种保证。所以如果写成：1234void f()&#123; int i; i++;&#125; 因为你只是声明了i，并没有对i进行初始化，所以在编译时会报错。 总结： 对于是基本类型的成员变量如果你只是声明了，没有进行初始化，那么 JVM会自动帮你进行初始化一个值，你可以直接操作这些基本类型的成员变量。 对于非基本类型的成员变量，如果没有声明那么JVM会初始化为一个特殊值null,你不能直接使用它，必须要new后才能使用它。 成员变量的初始化顺序就是他们在类中的顺序。 对于初始化成员变量你可以直接在定义变量的地方进行赋值，也可以通过方法对他们进行赋值。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"Hexo博客搭建(一：Hexo环境安装)","slug":"2018-11-12-1-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-12-05T14:02:23.867Z","comments":true,"path":"2018/11/12/2018-11-12-1-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-1-hexo/","excerpt":"","text":"1.安装Git Bash我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。 下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本：用命令 git version2.安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧。 下载地址 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本：用命令 node -v3.安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo 安装完成后，查看版本：用命令 hexo -v 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息4.创建github Reponsitory 首先,创建一个reponsitory如下图:注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README5.配置一下gitbash和github的通信协议 首先打开刚刚安装好的gitbash,界面如下: 配置gitbash和github的通信协议先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]},{"title":"Hexo博客搭建(三：在github上部署hexo主题)","slug":"2018-11-12-3-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T12:26:27.830Z","comments":true,"path":"2018/11/12/2018-11-12-3-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-3-hexo/","excerpt":"","text":"寻找主题 你可以到hexo官网主题页上去寻找自己想要的那种风格的hexo主题,每个主题作者都会有在github上的链接,一般链接会放在About页中,这里我以MiHo主题进行讲解。点击About:找到github链接,点击该链接:在跳转页面的overview中可以看到有hexo-theme-miho,点击hexo-theme-miho点解clone or download,让后将网址复制下来:打开gitbash进入到hexo初始化的那个blog页面执行git clone 复制的网址 themes/小写主题名称,然后回车执行命令,执行命令完,你会在blog中themes文件中发现多了一个小写主题名称(我这里是miho)的文件夹,这样就把复制的主题保存到了themes中。接下来就是调整themes中_config.yml中的一些配置这些都做完了，接下来应该怎么办呢？接下来就是将本地的静态博客部署到gitHub上，要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件，可以实现如下命令： npm install hexo -server –save npm install hexo-deployer-git –save编辑全局 hexo 的配置文件：_config.yml，这块可以参照网上的。 编辑全局配置后我们需要重新部署： 先清除掉已经生成的旧文件：hexo clean 再生成一次静态文件：hexo generate 在本地预览下：hexo server本地没问题之后，访问http://localhost:4000,如果成功了,Ctrl + C 停掉本地预览 使用部署命令部署到 Github 上：hexo deploy,如有弹出如下提示框，请输入：yes","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]},{"title":"Hexo博客搭建(二：Windows下如何使用gitbash管理github)","slug":"2018-11-12-2-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T12:44:38.151Z","comments":true,"path":"2018/11/12/2018-11-12-2-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-2-hexo/","excerpt":"","text":"4.创建github Reponsitory 首先,创建一个reponsitory如下图:注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README5.配置一下gitbash和github的通信协议 首先打开刚刚安装好的gitbash,界面如下: 配置gitbash和github的通信协议先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。 然后你就可以根据上图提示信息打开文件目录，找到那个文件 用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。重要的事情说三遍。然后打开github自己的主页Settings-&gt;SSH-&gt;newSSHkey不懂看下面的图： 刚刚全选复制的密钥就复制到Key哪里，title随便起。接下来要验证设置！输入命令：ssh –T git@github.com，问你yes or no，就输入yes，回车完事配置gitbash的用户名和邮箱：git config –-global user.name “用户名”git config –-global user.email “邮箱”用户名邮箱，用你github上的用户名和邮箱。 将你刚刚在github上创建的project和本地联系起来。 大致说下大概先，就是先在本地找个空的文件夹，然后用gitbash初始化一下这个文件夹的信息，使他变成一个类似于可以被管理的仓库，然后再从远程仓库github上pull上面的东西下来这个文件夹，然后自己修改好了，再push回去远程github，就这么简单。话不多说看图：我在D盘新建了一个名字为git2的文件夹，空的，啥都没有。然后用gitbash打开这个文件夹：具体命令就是cd 路径接下来就是git init:好了，本地的仓库做好了，是时候把远程仓库的东西拉下来了：命令：git remote add origin git@github.com:你的git 连接上之后，用pull:命令：git pull git@github.com:你的git我这里显示是Already up-to-date，因为我之前已经pull过一次了，你的可能不一样。然后你会发现你的本地仓库文件多了一个.md文件好了，这时候你要怎么把你想传的东西传到github上？比如我新建一个test文档，里面的内容是11111.自己手动新建的，手动，就是直接新建的小伙子。然后我们需要大概就是三个步骤就可以把这个test文件送到github上，git add-&gt;git commit-&gt;git push/////////////////////////////////////////////////////////完整写法看图：每一个$后面的就是我打的命令，当然git add后面跟一个.代表把所有文件都加进去，单独给出特定的文件名字就加特定的文件。然后你就会发现你的github上就多个了文件了后来你想修改的话，就一样的操作啊，pull下来手动修改，add，commit，push。","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]}]}