{"meta":{"title":"Java博客","subtitle":"记录自己每一个脚印","description":"我的个人站，主要涉及前后端端知识共享、实践教程、前沿技术共同学习等方面","author":"王文昊","url":"https://javazhan.com"},"pages":[{"title":"关于","date":"2016-01-31T14:10:28.000Z","updated":"2018-11-11T13:18:08.000Z","comments":true,"path":"about/index.html","permalink":"https://javazhan.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-12T10:09:35.853Z","updated":"2018-11-09T08:20:36.000Z","comments":false,"path":"categories/index.html","permalink":"https://javazhan.com/categories/index.html","excerpt":"","text":""},{"title":"留言","date":"2016-02-01T12:29:57.000Z","updated":"2018-11-09T13:55:04.000Z","comments":true,"path":"comment/index.html","permalink":"https://javazhan.com/comment/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-12T10:09:35.862Z","updated":"2018-11-09T08:20:20.000Z","comments":false,"path":"tags/index.html","permalink":"https://javazhan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于java的初始化( 一：成员变量的初始化 )","slug":"2018-11-13-1-java-initial-1","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T03:43:26.000Z","comments":true,"path":"2018/11/13/2018-11-13-1-java-initial-1/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/","excerpt":"","text":"关于成员变量的初始化Java会尽力保证:所有变量在使用前都能得到恰当的初始化。如果是成员变量是基本类型，类的每个基本类型的成员变量保证都会有一个初始值，如果成员变量是一个非基本类型，那么它将被初始化成一个特殊值null。下面的程序可以验证这种情况，Dog是一个注意他们的输出:1234567891011121314151617181920212223public class InitialVars()&#123; private boolean t; private char c; private byte b; private short s; private int i; private long l; private float f; private double d; private String st; public void printVars()&#123; System.out.println(&quot;输出结果为:&quot;); System.out.println(&quot;boolean--&gt;&quot;+t); System.out.println(&quot;char--&gt;&quot;+c); System.out.println(&quot;byte--&gt;&quot;+b); System.out.println(&quot;short--&gt;&quot;+s); System.out.println(&quot;int--&gt;&quot;+i); System.out.println(&quot;long--&gt;&quot;+l); System.out.println(&quot;float--&gt;&quot;+f); System.out.println(&quot;double--&gt;&quot;+d); System.out.println(&quot;String--&gt;&quot;+st); &#125;&#125; 输出结果为:boolean–&gt;false;char–&gt;byte–&gt;0short–&gt;0int–&gt;0long–&gt;0float–&gt;0.0double–&gt;0.0String–&gt;null可见尽管是基本类型的数据成员的初始值没有给出，但他们确实有值(char值为0,所以为空白)，你可以直接使用这些基本类型的成员变量，而非基本类型的成员变量初始值为null,你必须重新new它才可以使用，这样至少不会冒”未初始化变量”的风险了。 指定初始化如果你想为某个变量赋初始值，该怎么做呢？有一种很直接的办法，就是在定义类变量的地方直接为其赋值。以下代码片段修改了InitialVars类成员变量的定义，直接提供了初值。1234567891011public class InitialVarsOne()&#123; private boolean t = true; private char c = &apos;x&apos;; private byte b = 47; private short s = 0xff; private int i = 999; private long l = 1; private float f = 3.14f; private double d = 3.1415936; private String st = new String();&#125; 你还可以通过调用方法来初始化成员变量,举个简单例子： 1234567public class InitialVarsTwo()&#123; private int i = initialInt(); public int initialInt()&#123; return 3; &#125;&#125; 同时调用的方法中还可以是参数，但是这些参数必须是初始化后的，举个例子:1234567public class InitialVarsThree()&#123; private int j = 3; private int i = initialInt(j); public int initialInt(int vlaue)&#123; return value; &#125;&#125; 上面这样是可以的，但是像下面这样就不可以了:1234567public class InitialVarsFour()&#123; private int i = initialInt(j); private int j = 3; public int initialInt(int vlaue)&#123; return value; &#125;&#125; 此时初始化i的时候j还没有被初始化，所以编译会报错。显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以编译器恰当的对”向前引用”发出了警告。 对于方法中的局部变量,Java以编译时错误的形式来贯彻这种保证。所以如果写成：1234void f()&#123; int i; i++;&#125; 因为你只是声明了i，并没有对i进行初始化，所以在编译时会报错。 总结： 对于是基本类型的成员变量如果你只是声明了，没有进行初始化，那么 JVM会自动帮你进行初始化一个值，你可以直接操作这些基本类型的成员变量。 对于非基本类型的成员变量，如果没有声明那么JVM会初始化为一个特殊值null,你不能直接使用它，必须要new后才能使用它。 成员变量的初始化顺序就是他们在类中的顺序。 对于初始化成员变量你可以直接在定义变量的地方进行赋值，也可以通过方法对他们进行赋值。","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 二：构造器的初始化 )","slug":"2018-11-13-2-java-initial-2","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T07:02:24.000Z","comments":true,"path":"2018/11/13/2018-11-13-2-java-initial-2/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/","excerpt":"","text":"可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：123456public class Counter()&#123; int i; public Count()&#123; i = 7; &#125;&#125; 那么i首先会被置0，然后变为7，对于所有基本类型和对象的引用，包括在定义时已经指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前对元素进行初始化————因为初始化早已得到了保证。 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。及时变量定义散布于方法定义之间或者之后，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。例如：123456789101112131415161718192021222324public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125;&#125;public class Animal &#123; private Dog dog = new Dog(1); public Animal() &#123; new Dog(2); &#125; private Dog dog1 = new Dog(3); public void printf() &#123; new Dog(4); &#125; private Dog dog2 = new Dog(5);&#125;public class Test &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.printf(); &#125;&#125; 输出结果为：Dog1Dog3Dog5Dog2Dog4 在Animal类中，故意把几个Dog对象定义散布到各处，以证明它们全都会在构造器或其他方法之前的得到初始化。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null。如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。静态初始化只有在必要时刻才会进行，如果既不创建类也不引用 类.静态成员变量或者静态成员方法，那么静态的成员变量永远不会被创建。初始化的顺序是先静态成员变量后”非静态”成员变量。 显示的静态初始化Java语序将多个静态初始化动作组织成一个特殊的”静态子句”(有时也叫作”静态块”),与其他静态初始化动作一样，这样的静态块也是只执行一次：档首次生成这个类的一个对象时或者首次访问属于那个类的静态数据成员时。1234567891011121314151617181920212223public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125; public void f() &#123; System.out.println(&quot;print&quot;); &#125;&#125;public class Animal &#123; public static Dog dog1; public static Dog dog2; static &#123; dog1 = new Dog(1); dog2 = new Dog(2); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Animal.dog1.f(); &#125;&#125; 输出结果为Dog1Dog2print 非静态实例初始化Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量，例如:1234567891011121314151617181920212223public class Dog &#123; public Dog(int value) &#123; System.out.println(&quot;Dog&quot;+value); &#125;&#125;public class Animal &#123; public Dog dog1; public Dog dog2; public Animal()&#123; System.out.println(&quot;Initial Animal Constructor&quot;); &#125; &#123; dog1 = new Dog(1); dog2 = new Dog(2); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new Animal(); &#125;&#125; 输出结果为:Dog1Dog2Initial Animal Constructor从输出结果可以看出实例的初始化子句是在构造器之前执行的。 总结： 成员变量自动初始化的进行是无法阻止的，它将在构造器被调用之前发生。 成员变量的定义散布于方法定义之间或者之后，但无论如何它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。 static关键字不能应用于局部变量，因此它只能作用于域。 如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null，如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。 初始化的顺序是先静态成员变量后”非静态”成员变量。 当new一个类时初始化顺序为：静态数据初始化–&gt;非静态的成员变量初始化–&gt;构造器初始化","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 三：数组的初始化 )","slug":"2018-11-13-3-java-initial-3","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T09:21:18.000Z","comments":true,"path":"2018/11/13/2018-11-13-3-java-initial-3/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/","excerpt":"","text":"数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。 一位数组的初始化一维数组的声明：int[] arr;方括号也可以置于标识符后面：int arr[];两种格式的含义都一样的，没有什么区别，通常C,C++程序猿习惯用第二种写法，不过前一种更合理，java程序猿的话推荐使用第一种写法。一位数组的初始化,如果是int基本类型,并且知道其值和长度时：int[] arr = {1,3,5,7,9}shuint[] arr = new int[]{1,3,5,7,9}上面这个两个数组初始化方法是等价的，没有什么区别如果不知道数组的值和长度时，可以采用以下初始化方法：int[] arr = new int[20]上面的20表示数组初始化的一个大概长度;如果用java.util.Arrays中的toString(arr)方法对数组进行输出，输出结果为：[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 二维数组的初始化二维数组的声明：int[][] arr;方括号也可以置于标识符后面：int arr[][];二维数组的初始化，以int基本类型举例12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; //二维数组的初始化第一步 Integer[][] values = new Integer[3][];//只定义了二维数组的一维长度为3,二维长度可以不定义 //也可以是Integer[][] values = new Integer[2][4] 这样就定义了数组在二维上的长度为4 for(int i=0;i&lt;values.length;i++) &#123; values[i] = new Integer[4];//定义了二维长度为4 for(int j=0;j&lt;values[i].length;j++) &#123; values[i][j] = new Integer(i+j); &#125; &#125; for(int i=0;i&lt;values.length;i++) &#123; for(int j=0;j&lt;values[i].length;j++) &#123; System.out.print(values[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 可变参数列表在可变参数列表中可以放入与该可变的参数类型相同的数组，举例：123456789101112public class Test &#123; public static void printObject(Integer...values) &#123;//可变参数 for(Integer value:values) &#123; System.out.println(value.intValue()); &#125; &#125; public static void main(String[] args) &#123; Integer[] values = &#123;1,3,5,7,9&#125;; printObject(values);//可将数组传入到可变参数中 &#125;&#125; 但需注意的是，传入的数组必须是一个一维数组，如果传入的是二维数组，那么在编译过程中会报错。总结： 一维数组初始化有三种形式int[] arr = {1,3,5,7,9};int[] arr = new int[]{1,3,5,7,9};int[] arr = new int[20]; 二维数组初始化有两种方式int[][] arr = new int[3][4];int[][] arr = new int[3][];//二维长度在赋值一维时定义长度，例如 arr[0] = new int[4]此时定义二维长度为4 可变参数中可以传入装入的类型与可变参数类型相同的数组，单数组必须是一维数组","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"关于java的初始化( 三：数组的初始化 )","slug":"2018-11-13-4-java-enum-1","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T09:32:02.000Z","comments":true,"path":"2018/11/13/2018-11-13-4-java-enum-1/","link":"","permalink":"https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://javazhan.com/categories/后端/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://javazhan.com/tags/java基础/"}]},{"title":"Hexo博客搭建(一：hexo环境搭建)","slug":"2018-11-12-1-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T10:56:20.406Z","comments":true,"path":"2018/11/12/2018-11-12-1-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-1-hexo/","excerpt":"","text":"1.安装Git Bash我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。 下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本：用命令 git version2.安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧。 下载地址 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本：用命令 node -v3.安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo 安装完成后，查看版本：用命令 hexo -v 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]},{"title":"Hexo博客搭建(三：在github上部署hexo主题)","slug":"2018-11-12-3-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T12:26:27.830Z","comments":true,"path":"2018/11/12/2018-11-12-3-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-3-hexo/","excerpt":"","text":"寻找主题 你可以到hexo官网主题页上去寻找自己想要的那种风格的hexo主题,每个主题作者都会有在github上的链接,一般链接会放在About页中,这里我以MiHo主题进行讲解。点击About:找到github链接,点击该链接:在跳转页面的overview中可以看到有hexo-theme-miho,点击hexo-theme-miho点解clone or download,让后将网址复制下来:打开gitbash进入到hexo初始化的那个blog页面执行git clone 复制的网址 themes/小写主题名称,然后回车执行命令,执行命令完,你会在blog中themes文件中发现多了一个小写主题名称(我这里是miho)的文件夹,这样就把复制的主题保存到了themes中。接下来就是调整themes中_config.yml中的一些配置这些都做完了，接下来应该怎么办呢？接下来就是将本地的静态博客部署到gitHub上，要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件，可以实现如下命令： npm install hexo -server –save npm install hexo-deployer-git –save编辑全局 hexo 的配置文件：_config.yml，这块可以参照网上的。 编辑全局配置后我们需要重新部署： 先清除掉已经生成的旧文件：hexo clean 再生成一次静态文件：hexo generate 在本地预览下：hexo server本地没问题之后，访问http://localhost:4000,如果成功了,Ctrl + C 停掉本地预览 使用部署命令部署到 Github 上：hexo deploy,如有弹出如下提示框，请输入：yes","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]},{"title":"Hexo博客搭建(二：Windows下如何使用gitbash管理github)","slug":"2018-11-12-2-hexo","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T12:44:38.151Z","comments":true,"path":"2018/11/12/2018-11-12-2-hexo/","link":"","permalink":"https://javazhan.com/2018/11/12/2018-11-12-2-hexo/","excerpt":"","text":"4.创建github Reponsitory 首先,创建一个reponsitory如下图:注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README5.配置一下gitbash和github的通信协议 首先打开刚刚安装好的gitbash,界面如下: 配置gitbash和github的通信协议先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。 然后你就可以根据上图提示信息打开文件目录，找到那个文件 用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。重要的事情说三遍。然后打开github自己的主页Settings-&gt;SSH-&gt;newSSHkey不懂看下面的图： 刚刚全选复制的密钥就复制到Key哪里，title随便起。接下来要验证设置！输入命令：ssh –T git@github.com，问你yes or no，就输入yes，回车完事配置gitbash的用户名和邮箱：git config –-global user.name “用户名”git config –-global user.email “邮箱”用户名邮箱，用你github上的用户名和邮箱。 将你刚刚在github上创建的project和本地联系起来。 大致说下大概先，就是先在本地找个空的文件夹，然后用gitbash初始化一下这个文件夹的信息，使他变成一个类似于可以被管理的仓库，然后再从远程仓库github上pull上面的东西下来这个文件夹，然后自己修改好了，再push回去远程github，就这么简单。话不多说看图：我在D盘新建了一个名字为git2的文件夹，空的，啥都没有。然后用gitbash打开这个文件夹：具体命令就是cd 路径接下来就是git init:好了，本地的仓库做好了，是时候把远程仓库的东西拉下来了：命令：git remote add origin git@github.com:你的git 连接上之后，用pull:命令：git pull git@github.com:你的git我这里显示是Already up-to-date，因为我之前已经pull过一次了，你的可能不一样。然后你会发现你的本地仓库文件多了一个.md文件好了，这时候你要怎么把你想传的东西传到github上？比如我新建一个test文档，里面的内容是11111.自己手动新建的，手动，就是直接新建的小伙子。然后我们需要大概就是三个步骤就可以把这个test文件送到github上，git add-&gt;git commit-&gt;git push/////////////////////////////////////////////////////////完整写法看图：每一个$后面的就是我打的命令，当然git add后面跟一个.代表把所有文件都加进去，单独给出特定的文件名字就加特定的文件。然后你就会发现你的github上就多个了文件了后来你想修改的话，就一样的操作啊，pull下来手动修改，add，commit，push。","categories":[{"name":"前端","slug":"前端","permalink":"https://javazhan.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://javazhan.com/tags/Hexo/"}]},{"title":"我是一个新标题1","slug":"ceshi","date":"2017-06-17T16:00:00.000Z","updated":"2018-11-12T05:30:54.000Z","comments":true,"path":"2017/06/18/ceshi/","link":"","permalink":"https://javazhan.com/2017/06/18/ceshi/","excerpt":"","text":"我是一个新摘要1费附加按时交付撒富兰克林奇偶为江湖梦阔怕老大哥跑得快日投票记得吗这一个衣服撒即可吗发发看顾客考法拉克麻辣面风格更好二等分我是一个新摘要2费附加按时交付撒富兰克林奇偶为江湖梦阔怕老大哥跑得快日投票记得吗这一个衣服撒即可吗发发看顾客考法拉克麻辣面风格更好二等分我是一个新摘要3费附加按时交付撒富兰克林奇偶为江湖梦阔怕老大哥跑得快日投票记得吗这一个衣服撒即可吗发发看顾客考法拉克麻辣面风格更好二等分我是一个新摘要4费附加按时交付撒富兰克林奇偶为江湖梦阔怕老大哥跑得快日投票记得吗这一个衣服撒即可吗发发看顾客考法拉克麻辣面风格更好二等分 我是一个新内容","categories":[{"name":"新分类1","slug":"新分类1","permalink":"https://javazhan.com/categories/新分类1/"}],"tags":[{"name":"新标签一1","slug":"新标签一1","permalink":"https://javazhan.com/tags/新标签一1/"},{"name":"新标签二1","slug":"新标签二1","permalink":"https://javazhan.com/tags/新标签二1/"}]}]}