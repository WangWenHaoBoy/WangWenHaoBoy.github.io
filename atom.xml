<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Java博客</title>
  
  <subtitle>记录自己每一个脚印</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://javazhan.com/"/>
  <updated>2018-11-13T03:43:26.000Z</updated>
  <id>https://javazhan.com/</id>
  
  <author>
    <name>王文昊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于java的初始化( 一：成员变量的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T03:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于成员变量的初始化"><a href="#关于成员变量的初始化" class="headerlink" title="关于成员变量的初始化"></a>关于成员变量的初始化</h3><p>Java会尽力保证:所有变量在使用前都能得到恰当的初始化。<br>如果是成员变量是基本类型，类的每个基本类型的成员变量保证都会有一个初始值，如果成员变量是一个非基本类型，那么它将被初始化成一个特殊值null。下面的程序可以验证这种情况，Dog是一个注意他们的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVars()&#123;</span><br><span class="line">private boolean t;</span><br><span class="line">private char c;</span><br><span class="line">private byte b;</span><br><span class="line">private short s;</span><br><span class="line">private int i;</span><br><span class="line">private long l;</span><br><span class="line">private float f;</span><br><span class="line">private double d;</span><br><span class="line">private String st;</span><br><span class="line">public void printVars()&#123;</span><br><span class="line">    System.out.println(&quot;输出结果为:&quot;);</span><br><span class="line">    System.out.println(&quot;boolean--&gt;&quot;+t);</span><br><span class="line">    System.out.println(&quot;char--&gt;&quot;+c);</span><br><span class="line">    System.out.println(&quot;byte--&gt;&quot;+b);</span><br><span class="line">    System.out.println(&quot;short--&gt;&quot;+s);</span><br><span class="line">    System.out.println(&quot;int--&gt;&quot;+i);</span><br><span class="line">    System.out.println(&quot;long--&gt;&quot;+l);</span><br><span class="line">    System.out.println(&quot;float--&gt;&quot;+f);</span><br><span class="line">    System.out.println(&quot;double--&gt;&quot;+d);</span><br><span class="line">    System.out.println(&quot;String--&gt;&quot;+st);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>boolean–&gt;false;<br>char–&gt;<br>byte–&gt;0<br>short–&gt;0<br>int–&gt;0<br>long–&gt;0<br>float–&gt;0.0<br>double–&gt;0.0<br>String–&gt;null<br>可见尽管是基本类型的数据成员的初始值没有给出，但他们确实有值(char值为0,所以为空白)，你可以直接使用这些基本类型的成员变量，而非基本类型的成员变量初始值为null,你必须重新new它才可以使用，这样至少不会冒”未初始化变量”的风险了。</p><p>指定初始化<br>如果你想为某个变量赋初始值，该怎么做呢？有一种很直接的办法，就是在定义类变量的地方直接为其赋值。以下代码片段修改了InitialVars类成员变量的定义，直接提供了初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsOne()&#123;</span><br><span class="line">private boolean t = true;</span><br><span class="line">private char c = &apos;x&apos;;</span><br><span class="line">private byte b = 47;</span><br><span class="line">private short s = 0xff;</span><br><span class="line">private int i = 999;</span><br><span class="line">private long l = 1;</span><br><span class="line">private float f = 3.14f;</span><br><span class="line">private double d = 3.1415936;</span><br><span class="line">private String st = new String();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你还可以通过调用方法来初始化成员变量,举个简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsTwo()&#123;</span><br><span class="line">    private int i = initialInt();</span><br><span class="line">    public int initialInt()&#123;</span><br><span class="line">    return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时调用的方法中还可以是参数，但是这些参数必须是初始化后的，举个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsThree()&#123;</span><br><span class="line">    private int j = 3;</span><br><span class="line">private int i = initialInt(j);</span><br><span class="line">    public int initialInt(int vlaue)&#123;</span><br><span class="line">    return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这样是可以的，但是像下面这样就不可以了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsFour()&#123;</span><br><span class="line">    private int i = initialInt(j);</span><br><span class="line">    private int j = 3;</span><br><span class="line">    public int initialInt(int vlaue)&#123;</span><br><span class="line">    return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时初始化i的时候j还没有被初始化，所以编译会报错。<br>显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以编译器恰当的对”向前引用”发出了警告。</p><p>对于方法中的局部变量,Java以编译时错误的形式来贯彻这种保证。所以如果写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为你只是声明了i，并没有对i进行初始化，所以在编译时会报错。</p><p>总结：</p><ul><li>对于是基本类型的成员变量如果你只是声明了，没有进行初始化，那么 JVM会自动帮你进行初始化一个值，你可以直接操作这些基本类型的成员变量。</li><li>对于非基本类型的成员变量，如果没有声明那么JVM会初始化为一个特殊值null,你不能直接使用它，必须要new后才能使用它。</li><li>成员变量的初始化顺序就是他们在类中的顺序。</li><li>对于初始化成员变量你可以直接在定义变量的地方进行赋值，也可以通过方法对他们进行赋值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于成员变量的初始化&quot;&gt;&lt;a href=&quot;#关于成员变量的初始化&quot; class=&quot;headerlink&quot; title=&quot;关于成员变量的初始化&quot;&gt;&lt;/a&gt;关于成员变量的初始化&lt;/h3&gt;&lt;p&gt;Java会尽力保证:所有变量在使用前都能得到恰当的初始化。&lt;br&gt;如果是成员
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 二：构造器的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T07:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Counter()&#123;</span><br><span class="line">int i;</span><br><span class="line">    public Count()&#123;</span><br><span class="line">i = 7;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么i首先会被置0，然后变为7，对于所有基本类型和对象的引用，包括在定义时已经指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前对元素进行初始化————因为初始化早已得到了保证。</p><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。及时变量定义散布于方法定义之间或者之后，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">private Dog dog = new Dog(1);</span><br><span class="line">public Animal() &#123;</span><br><span class="line">new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">private Dog dog1 = new Dog(3);</span><br><span class="line">public void printf() &#123;</span><br><span class="line">new Dog(4);</span><br><span class="line">&#125;</span><br><span class="line">private Dog dog2 = new Dog(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">animal.printf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br>Dog1<br>Dog3<br>Dog5<br>Dog2<br>Dog4</p><p>在Animal类中，故意把几个Dog对象定义散布到各处，以证明它们全都会在构造器或其他方法之前的得到初始化。</p><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null。<br>如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。<br>静态初始化只有在必要时刻才会进行，如果既不创建类也不引用 类.静态成员变量或者静态成员方法，那么静态的成员变量永远不会被创建。<br>初始化的顺序是先静态成员变量后”非静态”成员变量。</p><h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3><p>Java语序将多个静态初始化动作组织成一个特殊的”静态子句”(有时也叫作”静态块”),与其他静态初始化动作一样，这样的静态块也是只执行一次：档首次生成这个类的一个对象时或者首次访问属于那个类的静态数据成员时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">public  void f() &#123;</span><br><span class="line">System.out.println(&quot;print&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">public static Dog dog1;</span><br><span class="line">public static Dog dog2;</span><br><span class="line">static &#123;</span><br><span class="line">dog1 = new Dog(1);</span><br><span class="line">dog2 = new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal.dog1.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为<br>Dog1<br>Dog2<br>print</p><h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">public  Dog dog1;</span><br><span class="line">public  Dog dog2;</span><br><span class="line">public Animal()&#123;</span><br><span class="line">System.out.println(&quot;Initial Animal Constructor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">dog1 = new Dog(1);</span><br><span class="line">dog2 = new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Animal();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>Dog1<br>Dog2<br>Initial Animal Constructor<br>从输出结果可以看出实例的初始化子句是在构造器之前执行的。</p><p>总结：</p><ul><li>成员变量自动初始化的进行是无法阻止的，它将在构造器被调用之前发生。</li><li>成员变量的定义散布于方法定义之间或者之后，但无论如何它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。</li><li>static关键字不能应用于局部变量，因此它只能作用于域。</li><li>如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null，如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。</li><li>初始化的顺序是先静态成员变量后”非静态”成员变量。</li><li>当new一个类时初始化顺序为：静态数据初始化–&gt;非静态的成员变量初始化–&gt;构造器初始化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 三：数组的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T09:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。</p><h3 id="一位数组的初始化"><a href="#一位数组的初始化" class="headerlink" title="一位数组的初始化"></a>一位数组的初始化</h3><p>一维数组的声明：<br>int[] arr;<br>方括号也可以置于标识符后面：<br>int arr[];<br>两种格式的含义都一样的，没有什么区别，通常C,C++程序猿习惯用第二种写法，不过前一种更合理，java程序猿的话推荐使用第一种写法。<br>一位数组的初始化,如果是int基本类型,并且知道其值和长度时：<br>int[] arr = {1,3,5,7,9}shu<br>int[] arr = new int[]{1,3,5,7,9}<br>上面这个两个数组初始化方法是等价的，没有什么区别<br>如果不知道数组的值和长度时，可以采用以下初始化方法：<br>int[] arr = new int[20]<br>上面的20表示数组初始化的一个大概长度;<br>如果用java.util.Arrays中的toString(arr)方法对数组进行输出，输出结果为：<br>[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的声明：<br>int[][] arr;<br>方括号也可以置于标识符后面：<br>int arr[][];<br>二维数组的初始化，以int基本类型举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//二维数组的初始化第一步</span><br><span class="line">    Integer[][] values = new Integer[3][];//只定义了二维数组的一维长度为3,二维长度可以不定义</span><br><span class="line">    //也可以是Integer[][] values = new Integer[2][4] 这样就定义了数组在二维上的长度为4</span><br><span class="line">    for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">    values[i] = new Integer[4];//定义了二维长度为4</span><br><span class="line">    for(int j=0;j&lt;values[i].length;j++) &#123;</span><br><span class="line">    values[i][j] = new Integer(i+j);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">    for(int j=0;j&lt;values[i].length;j++) &#123;</span><br><span class="line">    System.out.print(values[i][j]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>在可变参数列表中可以放入与该可变的参数类型相同的数组，举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void printObject(Integer...values) &#123;//可变参数</span><br><span class="line">for(Integer value:values) &#123;</span><br><span class="line">System.out.println(value.intValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer[] values = &#123;1,3,5,7,9&#125;;</span><br><span class="line">printObject(values);//可将数组传入到可变参数中</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但需注意的是，传入的数组必须是一个一维数组，如果传入的是二维数组，那么在编译过程中会报错。<br>总结：</p><ul><li>一维数组初始化有三种形式<br>int[] arr = {1,3,5,7,9};<br>int[] arr = new int[]{1,3,5,7,9};<br>int[] arr = new int[20];</li><li>二维数组初始化有两种方式<br>int[][] arr = new int[3][4];<br>int[][] arr = new int[3][];//二维长度在赋值一维时定义长度，例如 arr[0] = new int[4]此时定义二维长度为4</li><li>可变参数中可以传入装入的类型与可变参数类型相同的数组，单数组必须是一维数组</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。&lt;/p&gt;
&lt;h3 id=&quot;一位数组的初始化&quot;&gt;&lt;a href=&quot;#一位数组的初始化&quot; class=&quot;headerlink&quot; title=&quot;一位数组的初始化&quot;&gt;&lt;/a&gt;一位数组的初始化&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>初探Java枚举类型</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T13:39:44.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建一个enum"><a href="#创建一个enum" class="headerlink" title="创建一个enum"></a>创建一个enum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Season&#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个名为季节Season的枚举类型，它具有四个具名值，春天SPRING,夏天SUMMER,秋天AUTUMN,冬天WINTER，由于枚举类型的实例是常量，因此按照命名惯例他们都用大写字母表示(如果在一个名字中有多个单词，用下划线将他们隔开)。<br>为了使用enum，需要创建一个该类型的引用，并将其复制给某个实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Season season = Season.AUTUMN;</span><br><span class="line">System.out.println(season);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>AUTUMN<br>在你创建enum时，编译器会自动添加一些有用的特性。例如，他会创建一个toString()方法，以便于很方便的显示某个enum的名字，这正上上面打印语句如何产生其输出的答案。编译器还会创建一个ordinal()的方法，用来表示某个特定enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量构成的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for(Season season:Season.values()) &#123;</span><br><span class="line">System.out.println(season+&quot;.ordinal--&gt;&quot;+season.ordinal());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>SPRING.ordinal–&gt;0<br>SUMMER.ordinal–&gt;1<br>AUTUMN.ordinal–&gt;2<br>WINTER.ordinal–&gt;3<br>尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应的类时，产生某些编译上的行为，因此在很大程度上，你可以将enum当作其他任何类来处理。事实上enum确实是类，并且具有自己的方法。<br>enum有一个特别实用的特性，即它可以在switch语句内使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Season season = Season.SPRING;</span><br><span class="line">switch (season) &#123;</span><br><span class="line">case SPRING:</span><br><span class="line">System.out.println(&quot;SPRING&quot;);</span><br><span class="line">break;</span><br><span class="line">case SUMMER:</span><br><span class="line">System.out.println(&quot;SUMMER&quot;);</span><br><span class="line">break;</span><br><span class="line">case AUTUMN:</span><br><span class="line">System.out.println(&quot;AUTUMN&quot;);</span><br><span class="line">break;</span><br><span class="line">case WINTER:</span><br><span class="line">System.out.println(&quot;WINTER&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;DEFAULT&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>SPRING<br>由于switch时要在有限的几何中进行选择，因此它与enum正是绝佳的组合。</p><p>总结：</p><ul><li>enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应的类时，产生某些编译上的行为，因此在很大程度上，你可以将enum当作其他任何类来处理,事实上enum确实是类，并且具有自己的方法。</li><li>创建enum时，编译器会自动添加一些有用的特性，例如增加toString()和static values()以及ordinal()方法等…</li><li>enum有一个特别实用的特性，即它可以在switch语句内使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建一个enum&quot;&gt;&lt;a href=&quot;#创建一个enum&quot; class=&quot;headerlink&quot; title=&quot;创建一个enum&quot;&gt;&lt;/a&gt;创建一个enum&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建(一：hexo环境搭建)</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-1-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-1-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T10:56:20.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装Git-Bash"><a href="#1-安装Git-Bash" class="headerlink" title="1.安装Git Bash"></a>1.安装Git Bash</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ol><li><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：双击下载好的exe文件，一路next就好啦</li><li>安装好后，打开gitbash，查看版本：用命令 <code>git version</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/0.png" alt=""><h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h3>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧。</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 <code>win + r</code> 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：用命令 <code>node -v</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/1.png" alt=""><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3>看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。</li><li>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo</li><li>安装完成后，查看版本：用命令 <code>hexo -v</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/2.png" alt=""></li><li>初始化命令：<code>hexo init</code> ，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="https://javazhan.com/images/hexo/2018-11-12/3.png" alt=""></li><li>解释一下</li></ol><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装Git-Bash&quot;&gt;&lt;a href=&quot;#1-安装Git-Bash&quot; class=&quot;headerlink&quot; title=&quot;1.安装Git Bash&quot;&gt;&lt;/a&gt;1.安装Git Bash&lt;/h3&gt;&lt;p&gt;我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建(二：Windows下如何使用gitbash管理github)</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-2-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-2-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T12:44:38.151Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-创建github-Reponsitory"><a href="#4-创建github-Reponsitory" class="headerlink" title="4.创建github Reponsitory"></a>4.创建github Reponsitory</h3><ol><li>首先,创建一个reponsitory如下图:<br><img src="https://javazhan.com/images/hexo/2018-11-12/4.png" alt=""><br>注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README<br><img src="https://javazhan.com/images/hexo/2018-11-12/5.png" alt=""><h3 id="5-配置一下gitbash和github的通信协议"><a href="#5-配置一下gitbash和github的通信协议" class="headerlink" title="5.配置一下gitbash和github的通信协议"></a>5.配置一下gitbash和github的通信协议</h3></li><li>首先打开刚刚安装好的gitbash,界面如下:<br><img src="https://javazhan.com/images/hexo/2018-11-12/6.png" alt=""></li><li>配置gitbash和github的通信协议<br>先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。<br><img src="https://javazhan.com/images/hexo/2018-11-12/7.png" alt=""></li><li>然后你就可以根据上图提示信息打开文件目录，找到那个文件<br><img src="https://javazhan.com/images/hexo/2018-11-12/8.png" alt=""></li><li>用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。重要的事情说三遍。<br>然后打开github自己的主页Settings-&gt;SSH-&gt;newSSHkey<br>不懂看下面的图：<br><img src="https://javazhan.com/images/hexo/2018-11-12/9.png" alt=""></li></ol><p><img src="https://javazhan.com/images/hexo/2018-11-12/10.png" alt=""></p><p><img src="https://javazhan.com/images/hexo/2018-11-12/11.png" alt=""><br>刚刚全选复制的密钥就复制到Key哪里，title随便起。<br><img src="https://javazhan.com/images/hexo/2018-11-12/12.png" alt=""><br>接下来要验证设置！<br>输入命令：ssh –T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，问你yes or no，就输入yes，回车完事<br><img src="https://javazhan.com/images/hexo/2018-11-12/13.png" alt=""><br>配置gitbash的用户名和邮箱：<br>git config –-global user.name “用户名”<br>git config –-global user.email “邮箱”<br>用户名邮箱，用你github上的用户名和邮箱。 </p><h3 id="将你刚刚在github上创建的project和本地联系起来。"><a href="#将你刚刚在github上创建的project和本地联系起来。" class="headerlink" title="将你刚刚在github上创建的project和本地联系起来。"></a>将你刚刚在github上创建的project和本地联系起来。</h3><ol><li>大致说下大概先，就是先在本地找个空的文件夹，然后用gitbash初始化一下这个文件夹的信息，使他变成一个类似于可以被管理的仓库，然后再从远程仓库github上pull上面的东西下来这个文件夹，然后自己修改好了，再push回去远程github，就这么简单。<br>话不多说看图：<br><img src="https://javazhan.com/images/hexo/2018-11-12/14.png" alt=""><br>我在D盘新建了一个名字为git2的文件夹，空的，啥都没有。<br>然后用gitbash打开这个文件夹：<br>具体命令就是cd 路径<br><img src="https://javazhan.com/images/hexo/2018-11-12/15.png" alt=""><br>接下来就是git init:<br><img src="https://javazhan.com/images/hexo/2018-11-12/16.png" alt=""><br>好了，本地的仓库做好了，是时候把远程仓库的东西拉下来了：<br>命令：git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:你的git<br><img src="https://javazhan.com/images/hexo/2018-11-12/17.png" alt=""></li></ol><p><img src="https://javazhan.com/images/hexo/2018-11-12/18.png" alt=""><br>连接上之后，用pull:<br>命令：<br>git pull <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:你的git<br><img src="https://javazhan.com/images/hexo/2018-11-12/19.png" alt=""><br>我这里显示是Already up-to-date，因为我之前已经pull过一次了，你的可能不一样。然后你会发现<br>你的本地仓库文件多了一个.md文件<br><img src="https://javazhan.com/images/hexo/2018-11-12/21.png" alt=""><br>好了，这时候你要怎么把你想传的东西传到github上？<br>比如我新建一个test文档，里面的内容是11111.自己手动新建的，手动，就是直接新建的小伙子。<br>然后我们需要大概就是三个步骤就可以把这个test文件送到github上，<br>git add-&gt;git commit-&gt;git push<br>/////////////////////////////////////////////////////////<br>完整写法看图：<br>每一个$后面的就是我打的命令，当然git add后面跟一个.代表把所有文件都加进去，单独给出特定的文件名字就加特定的文件。<br><img src="https://javazhan.com/images/hexo/2018-11-12/22.png" alt=""><br>然后你就会发现你的github上就多个了文件了<br><img src="https://javazhan.com/images/hexo/2018-11-12/23.png" alt=""><br>后来你想修改的话，就一样的操作啊，pull下来<br>手动修改，add，commit，push。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-创建github-Reponsitory&quot;&gt;&lt;a href=&quot;#4-创建github-Reponsitory&quot; class=&quot;headerlink&quot; title=&quot;4.创建github Reponsitory&quot;&gt;&lt;/a&gt;4.创建github Reponsito
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建(三：在github上部署hexo主题)</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-3-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-3-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T12:26:27.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="寻找主题"><a href="#寻找主题" class="headerlink" title="寻找主题"></a>寻找主题</h3><ol><li>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网主题页</a>上去寻找自己想要的那种风格的hexo主题,每个主题作者都会有在github上的链接,一般链接会放在About页中,这里我以MiHo主题进行讲解。<br>点击About:<br><img src="https://javazhan.com/images/hexo/2018-11-12/24.png" alt=""><br>找到github链接,点击该链接:<br><img src="https://javazhan.com/images/hexo/2018-11-12/25.png" alt=""><br>在跳转页面的overview中可以看到有hexo-theme-miho,点击hexo-theme-miho<br><img src="https://javazhan.com/images/hexo/2018-11-12/26.png" alt=""><br>点解clone or download,让后将网址复制下来:<br><img src="https://javazhan.com/images/hexo/2018-11-12/27.png" alt=""><br>打开gitbash进入到hexo初始化的那个blog页面执行<code>git clone 复制的网址 themes/小写主题名称</code>,然后回车执行命令,执行命令完,你会在blog中themes文件中发现多了一个小写主题名称(我这里是miho)的文件夹,这样就把复制的主题保存到了themes中。<br><img src="https://javazhan.com/images/hexo/2018-11-12/28.png" alt=""><br>接下来就是调整themes中_config.yml中的一些配置<br>这些都做完了，接下来应该怎么办呢？<br>接下来就是将本地的静态博客部署到gitHub上，要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件，可以实现如下命令：</li></ol><ul><li>npm install hexo -server –save</li><li>npm install hexo-deployer-git –save<br>编辑全局 hexo 的配置文件：_config.yml，这块可以参照网上的。</li><li>编辑全局配置后我们需要重新部署：</li><li>先清除掉已经生成的旧文件：hexo clean</li><li>再生成一次静态文件：hexo generate</li><li>在本地预览下：hexo server本地没问题之后，访问<a href="http://localhost:4000,如果成功了,Ctrl" target="_blank" rel="noopener">http://localhost:4000,如果成功了,Ctrl</a> + C 停掉本地预览</li><li>使用部署命令部署到 Github 上：hexo deploy,如有弹出如下提示框，请输入：yes<br><img src="https://javazhan.com/images/hexo/2018-11-12/29.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;寻找主题&quot;&gt;&lt;a href=&quot;#寻找主题&quot; class=&quot;headerlink&quot; title=&quot;寻找主题&quot;&gt;&lt;/a&gt;寻找主题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;你可以到&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
