<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Java博客</title>
  
  <subtitle>记录自己每一个脚印</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://javazhan.com/"/>
  <updated>2018-11-28T06:00:28.000Z</updated>
  <id>https://javazhan.com/</id>
  
  <author>
    <name>王文昊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot系列之springboot整合mybatis</title>
    <link href="https://javazhan.com/2018/11/21/2018-11-28-2-java-springboot-mybatis-1/"/>
    <id>https://javazhan.com/2018/11/21/2018-11-28-2-java-springboot-mybatis-1/</id>
    <published>2018-11-20T16:00:00.000Z</published>
    <updated>2018-11-28T06:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--jdbc依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>创建配置文件application.yml<br>在src/main/source目录下创建配置文件application.yml<br>配置内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#配置访问端口</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">#配置数据库</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/test</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">#配置mybatis *Mapper.xml的位置</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br></pre></td></tr></table></figure></p><p>Student实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">public String getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(String id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StudentDao接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentDao &#123;</span><br><span class="line">List&lt;Student&gt; listStudent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StudentDao接口对应的studentMapper.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.wangwenhao.ssm.student.dao.StudentDao&quot;&gt;</span><br><span class="line">&lt;select id=&quot;listStudent&quot; resultType=&quot;com.wangwenhao.ssm.student.entity.Student&quot;&gt;</span><br><span class="line">select * from t_student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p>StudentService服务类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private StudentDao studentDao;</span><br><span class="line">public List&lt;Student&gt; listStudent()&#123;</span><br><span class="line">return studentDao.listStudent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StudentService控制类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;student&quot;)</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private StudentService studentService;</span><br><span class="line">@RequestMapping(value=&quot;view&quot;,method=RequestMethod.GET)</span><br><span class="line">@ResponseBody</span><br><span class="line">public List&lt;Student&gt; viewStudent() &#123;</span><br><span class="line">return studentService.listStudent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动启动类后访问<a href="http://localhost:8082/student/view" target="_blank" rel="noopener">http://localhost:8082/student/view</a><br>显示结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: &quot;111&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;wang&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: &quot;222&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;wen&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: &quot;333&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;hao&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>对应的是数据库的三条数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;添加依赖&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="springboot整合" scheme="https://javazhan.com/tags/springboot%E6%95%B4%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>springboot系列之springboot的创建</title>
    <link href="https://javazhan.com/2018/11/21/2018-11-28-1-java-springboot-1/"/>
    <id>https://javazhan.com/2018/11/21/2018-11-28-1-java-springboot-1/</id>
    <published>2018-11-20T16:00:00.000Z</published>
    <updated>2018-11-28T05:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建一个简单的maven项目"><a href="#创建一个简单的maven项目" class="headerlink" title="创建一个简单的maven项目"></a>创建一个简单的maven项目</h3><h3 id="添加在pom-xml添加springboot依赖"><a href="#添加在pom-xml添加springboot依赖" class="headerlink" title="添加在pom.xml添加springboot依赖"></a>添加在pom.xml添加springboot依赖</h3><p>springboot版本为 2.0.6.RELEASE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;myproject&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Inherit defaults from Spring Boot --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add typical dependencies for a web application --&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Package as an executable jar --&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h3 id="创建一个启动类"><a href="#创建一个启动类" class="headerlink" title="创建一个启动类"></a>创建一个启动类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SSMArchitecturetApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SSMArchitecturetApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个Student实体类"><a href="#创建一个Student实体类" class="headerlink" title="创建一个Student实体类"></a>创建一个Student实体类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">public String getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(String id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个控制类"><a href="#创建一个控制类" class="headerlink" title="创建一个控制类"></a>创建一个控制类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;student&quot;)</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">@RequestMapping(value=&quot;view&quot;,method=RequestMethod.GET)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Student viewStudent() &#123;</span><br><span class="line">Student student  = new Student();</span><br><span class="line">student.setId(&quot;one&quot;);</span><br><span class="line">student.setName(&quot;wangwenhao&quot;);</span><br><span class="line">return student;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动启动类"><a href="#启动启动类" class="headerlink" title="启动启动类"></a>启动启动类</h3><p>然后访问<a href="http://localhost:8080/student/view，" target="_blank" rel="noopener">http://localhost:8080/student/view，</a><br>返回结果为一个student的json值:<br>{<br>    “id”: “one”,<br>    “name”: “wangwenhao”<br>}</p><p>到这里一个基本的springboot框架就已经搭建好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建一个简单的maven项目&quot;&gt;&lt;a href=&quot;#创建一个简单的maven项目&quot; class=&quot;headerlink&quot; title=&quot;创建一个简单的maven项目&quot;&gt;&lt;/a&gt;创建一个简单的maven项目&lt;/h3&gt;&lt;h3 id=&quot;添加在pom-xml添加sprin
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="springboot整合" scheme="https://javazhan.com/tags/springboot%E6%95%B4%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java正则表达式之前瞻后顾</title>
    <link href="https://javazhan.com/2018/11/21/2018-11-21-1-java-regular-expression-1/"/>
    <id>https://javazhan.com/2018/11/21/2018-11-21-1-java-regular-expression-1/</id>
    <published>2018-11-20T16:00:00.000Z</published>
    <updated>2018-11-21T07:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>正则表达式的先行断言和后行断言一共有4种形式</p></blockquote><ul><li>(?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion)</li></ul><ul><li>(?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion)</li></ul><ul><li>(?&lt;=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion)</li></ul><ul><li>(?&lt;!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion)</li></ul><p>这里面的pattern是一个正则表达式。<br>如同^代表开头，$代表结尾，\b代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为“零宽”。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><blockquote><p>下面分别举例来说明这4种断言的含义</p></blockquote><ul><li><p>(?=pattern) 正向先行断言<br>代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。<br>例如对”a regular expression”这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用”re(?=gular)”，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为”re(?=gular).”，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。</p></li><li><p>(?!pattern) 负向先行断言<br>代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。<br>例如对”regex represents regular expression”这个字符串，要想匹配除regex和regular之外的re，可以用”re(?!g)”，该表达式限定了re右边的位置，这个位置后面不是字符g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。</p></li><li><p>(?&lt;=pattern) 正向后行断言<br>代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。<br>例如对”regex represents regular expression”这个字符串，有4个单词，要想匹配单词内部的re，但不匹配单词开头的re，可以用”(?&lt;=\w)re”，单词内部的re，在re前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。</p></li><li><p>(?&lt;!pattern) 负向后行断言<br>代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。<br>例如对”regex represents regular expression”这个字符串，要想匹配单词开头的re，可以用”(?&lt;!\w)re”。单词开头的re，在本例中，也就是指不在单词内部的re，即re前面不是单词字符。当然也可以用”\bre”来匹配。</p></li></ul><blockquote><p>注意</p></blockquote><p>上述4种断言，括号里的pattern本身是一个正则表达式。但对2种后行断言有所限制，在Perl和Python中，这个表达式必须是定长(fixed length)的，即不能使用<em>、+、?等元字符，如(?&lt;=abc)没有问题，但(?&lt;=a</em>bc)是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持?、{m}、{n,m}等符号，但同样不支持*、+字符。JavaScript干脆不支持后行断言，不过一般来说，这不是太大的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;正则表达式的先行断言和后行断言一共有4种形式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;(?=patt
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之建造者模式</title>
    <link href="https://javazhan.com/2018/11/19/2018-11-19-3-java-design-pattern-3/"/>
    <id>https://javazhan.com/2018/11/19/2018-11-19-3-java-design-pattern-3/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2018-11-19T09:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="red">建造者模式（Builder Pattern）</font>使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于<font color="red">创建型模式</font>，它提供了一种创建对象的最佳方式。</p></blockquote><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>意图</p></blockquote><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><blockquote><p>主要解决</p></blockquote><p>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><blockquote><p>何时使用</p></blockquote><p>一些基本部件不会变，而其组合经常变化的时候。</p><blockquote><p>如何解决</p></blockquote><p>将变与不变分离开。</p><blockquote><p>注意事项</p></blockquote><p>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，而工厂模式更加关注的是零件的类型。</p><blockquote><p>UML结构图</p></blockquote><p><img src="https://javazhan.com/images/disign-pattern/2018-11-19/3.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。</p><p>Item物品抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Item &#123;</span><br><span class="line">public abstract String getName();</span><br><span class="line">public abstract double getPrice();</span><br><span class="line">public abstract Package getPack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Burger汉堡包抽象类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Burger extends Item&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>VegBurger蔬菜汉堡包类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VegBurger extends Burger&#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;VegBurger&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 30.6;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Package getPack() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Wrapper();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ChickenBurger鸡肉汉堡吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ChickenBurger extends Burger &#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;ChickenBurger&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 23.3;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Package getPack() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Wrapper();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Drink饮料抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Drink extends Item&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Coke可口可乐类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Coke extends Drink&#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;Coke&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 5.3;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Package getPack() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Bottle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Pepsi百事可乐类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Pepsi extends Drink&#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;Pepsi&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 3.0;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Package getPack() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Bottle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>包装接口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface  Package &#123;</span><br><span class="line">public abstract String getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>袋装类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper implements Package &#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return &quot;Wrapper&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>瓶装类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Bottle implements Package &#123;</span><br><span class="line">@Override</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return &quot;Bottle&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Meal类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Meal &#123;</span><br><span class="line">private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();</span><br><span class="line">public void addItem(Item item) &#123;</span><br><span class="line">items.add(item);</span><br><span class="line">&#125;</span><br><span class="line">public void showTotalPrice() &#123;</span><br><span class="line">double price = 0;</span><br><span class="line">for(Item item : items) &#123;</span><br><span class="line">price+=item.getPrice();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(price);</span><br><span class="line">&#125;</span><br><span class="line">public void showAllName() &#123;</span><br><span class="line">for(Item item : items) &#123;</span><br><span class="line">System.out.println(item.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Meal构建类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MealBuilder &#123;</span><br><span class="line">public Meal BuildMealOne() &#123;</span><br><span class="line">Meal meal = new Meal();</span><br><span class="line">meal.addItem(new VegBurger());</span><br><span class="line">meal.addItem(new Coke());</span><br><span class="line">return meal;</span><br><span class="line">&#125;</span><br><span class="line">public Meal BuildMealTwo() &#123;</span><br><span class="line">Meal meal = new Meal();</span><br><span class="line">meal.addItem(new ChickenBurger());</span><br><span class="line">meal.addItem(new Pepsi());</span><br><span class="line">return meal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MealBuilder builder = new MealBuilder();</span><br><span class="line">Meal mealone = builder.BuildMealOne();</span><br><span class="line">mealone.showTotalPrice();</span><br><span class="line">mealone.showAllName();</span><br><span class="line">Meal mealtwo = builder.BuildMealTwo();</span><br><span class="line">mealtwo.showTotalPrice();</span><br><span class="line">mealtwo.showAllName();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br>35.9<br>VegBurger<br>Coke<br>26.3<br>ChickenBurger<br>Pepsi</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>优点</p></blockquote><ul><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>产品必须有共同点，范围有限制。</li><li>如内部变化复杂，会有很多的建造类。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;建造者模式（Builder Pattern）&lt;/font&gt;使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于&lt;font color=&quot;red&quot;&gt;创建型模式&lt;/font&gt;，它提供了一种创建对象的
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之装饰者模式</title>
    <link href="https://javazhan.com/2018/11/19/2018-11-19-1-java-design-pattern-1/"/>
    <id>https://javazhan.com/2018/11/19/2018-11-19-1-java-design-pattern-1/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2018-11-19T02:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="red">装饰器模式（Decorator Pattern）</font>允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于<font color="red">结构型模式</font>，它是作为现有的类的一个包装。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><blockquote><p>意图</p></blockquote><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><blockquote><p>主要解决</p></blockquote><p>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><blockquote><p>何时使用</p></blockquote><p>在不想增加很多子类的情况下扩展类。</p><blockquote><p>如何解决</p></blockquote><p>将具体功能职责划分，同时继承装饰者模式。</p><blockquote><p>注意事项</p></blockquote><p>可以替代继承</p><blockquote><p>UML结构图</p></blockquote><p><img src="https://javazhan.com/images/disign-pattern/2018-11-19/1.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>图形接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">public void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>长方形类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">@Override</span><br><span class="line">public void draw() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;drawShape:&quot;+this.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>圆形类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">@Override</span><br><span class="line">public void draw() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;drawShape:&quot;+this.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>装饰者接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Decorate &#123;</span><br><span class="line">protected Shape shape;</span><br><span class="line">public Decorate(Shape shape) &#123;</span><br><span class="line">this.shape = shape;</span><br><span class="line">&#125;</span><br><span class="line">public abstract void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>装饰者实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteDecorate extends Decorate &#123;</span><br><span class="line">public ConcreteDecorate(Shape shape) &#123;</span><br><span class="line">super(shape);</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void draw() &#123;</span><br><span class="line">System.out.println(&quot;setBorder for &quot;+shape.getClass().getSimpleName());</span><br><span class="line">shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Decorate d = new ConcreteDecorate(new Rectangle());</span><br><span class="line">d.draw();</span><br><span class="line">d = new ConcreteDecorate(new Circle());</span><br><span class="line">d.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>setBorder for Rectangle<br>drawShape:Rectangle<br>setBorder for Circle<br>drawShape:Circle</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>优点：</p></blockquote><ul><li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li></ul><blockquote><p>缺点：</p></blockquote><ul><li>多层装饰比较复杂。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;装饰器模式（Decorator Pattern）&lt;/font&gt;允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于&lt;font color=&quot;red&quot;&gt;结构型模式&lt;/font&gt;，它是作为现有
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之观察者模式</title>
    <link href="https://javazhan.com/2018/11/19/2018-11-19-2-java-design-pattern-2/"/>
    <id>https://javazhan.com/2018/11/19/2018-11-19-2-java-design-pattern-2/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2018-11-19T09:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当对象间存在一对多关系时，则使用<font color="red">观察者模式（Observer Pattern）</font>。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于<font color="red">行为型模式</font>。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>意图</p></blockquote><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><blockquote><p>主要解决</p></blockquote><p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><blockquote><p>何时使用</p></blockquote><p>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><blockquote><p>使用场景</p></blockquote><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<blockquote><p>UML结构图</p></blockquote></li></ul><p><img src="https://javazhan.com/images/disign-pattern/2018-11-19/2.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前台类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Reception &#123;</span><br><span class="line">private int state;</span><br><span class="line">private List&lt;DepartMent&gt; departMentList=new ArrayList&lt;DepartMent&gt;();</span><br><span class="line">public int getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line">public void setState(int state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">if(this.state==0) &#123;</span><br><span class="line">notifyAllStaff(&quot;老板来了&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">notifyAllStaff(&quot;老板走了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void attach(DepartMent staff) &#123;</span><br><span class="line">departMentList.add(staff);</span><br><span class="line">&#125;</span><br><span class="line">public void notifyAllStaff(String stateStr) &#123;</span><br><span class="line">for(DepartMent departMent : departMentList) &#123;</span><br><span class="line">departMent.update(stateStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部门抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DepartMent &#123;</span><br><span class="line">protected Reception reception;</span><br><span class="line">public DepartMent(Reception reception) &#123;</span><br><span class="line">this.reception = reception;</span><br><span class="line">&#125;</span><br><span class="line">public abstract void update(String stateStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部门A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DepartMentA extends DepartMent &#123;</span><br><span class="line">public DepartMentA(Reception reception) &#123;</span><br><span class="line">super(reception);</span><br><span class="line">this.reception.attach(this);</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void update(String stateStr) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部门B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DepartMentB extends DepartMent &#123;</span><br><span class="line">public DepartMentB(Reception reception) &#123;</span><br><span class="line">super(reception);</span><br><span class="line">this.reception.attach(this);</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void update(String stateStr) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部门C：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DepartMentC extends DepartMent &#123;</span><br><span class="line">public DepartMentC(Reception reception) &#123;</span><br><span class="line">super(reception);</span><br><span class="line">this.reception.attach(this);</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void update(String stateStr) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(this.getClass().getSimpleName()+&quot;接收到&quot;+reception.getClass().getSimpleName()+&quot;通知,&quot;+stateStr+&quot;,改变工作状态&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Reception reception = new Reception();</span><br><span class="line">new DepartMentA(reception);</span><br><span class="line">new DepartMentB(reception);</span><br><span class="line">new DepartMentC(reception);</span><br><span class="line">reception.setState(0);</span><br><span class="line">reception.setState(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br>DepartMentA接收到Reception通知,老板来了,改变工作状态<br>DepartMentB接收到Reception通知,老板来了,改变工作状态<br>DepartMentC接收到Reception通知,老板来了,改变工作状态<br>DepartMentA接收到Reception通知,老板走了,改变工作状态<br>DepartMentB接收到Reception通知,老板走了,改变工作状态<br>DepartMentC接收到Reception通知,老板走了,改变工作状态</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>优点</p></blockquote><ul><li>观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的被观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当对象间存在一对多关系时，则使用&lt;font color=&quot;red&quot;&gt;观察者模式（Observer Pattern）&lt;/font&gt;。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于&lt;font color=&quot;red&quot;&gt;行为型模式&lt;/f
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之访问者模式</title>
    <link href="https://javazhan.com/2018/11/17/2018-11-17-1-java-design-pattern-1/"/>
    <id>https://javazhan.com/2018/11/17/2018-11-17-1-java-design-pattern-1/</id>
    <published>2018-11-16T16:00:00.000Z</published>
    <updated>2018-11-17T05:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="red">访问者模式（Visitor Pattern）</font>属于<font color="red">对象行为型模式</font>的一种，表示一个作用于其对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>访问者模式</strong>： 预留通路，回调实现。它的实现主要就是通过预先定义好调用的通路，在被访问的对象上定义accept方法，在访问者的对象上定义visit方法；然后在调用真正发生的时候，通过两次分发的技术，利用预先定义好的通路，回调到访问者具体的实现上。</p><blockquote><p>主要解决</p></blockquote><p><strong>现已稳定的数据结构和易变的操作耦合问题，把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。</strong></p><blockquote><p>UML结构图</p></blockquote><p><div align="center"><br><img src="https://javazhan.com/images/disign-pattern/2018-11-17/1.png" alt=""><br></div></p><blockquote><p>模式结构</p></blockquote><ul><li><strong>抽象访问者(Visitor)</strong>： 定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变（不能改变的意思是说，如果元素类的个数经常改变，则说明不适合使用访问者模式）。</li><li><strong>具体访问者(ConcreteVisitor)</strong>： 给出对每一个元素类访问时所产生的具体行为。</li><li><strong>抽象节点(Element)</strong>： 定义了一个接受访问者（accept）的方法，其意义是指，每一个元素都要可以被访问者访问。</li><li><strong>具体节点(ConcreteElement)</strong>： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li><strong>结构对象角色(ObjectStructure)</strong>： 定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>场景：很多人都有养宠物的习惯，这里就以此为例</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><blockquote><p>结构图如下:</p></blockquote><p><img src="https://javazhan.com/images/disign-pattern/2018-11-17/2.png" alt=""><br>1.创建抽象访问者接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line"></span><br><span class="line">    void feed(Cat cat);</span><br><span class="line"></span><br><span class="line">    void feed(Dog dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建不同的具体访问者角色 – 主人/其他人，同时实现 Person接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Owner implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void feed(Cat cat) &#123;</span><br><span class="line">        System.out.println(&quot;主人喂食猫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void feed(Dog dog) &#123;</span><br><span class="line">        System.out.println(&quot;主人喂食狗&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Someone implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void feed(Cat cat) &#123;</span><br><span class="line">        System.out.println(&quot;其他人喂食猫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void feed(Dog dog) &#123;</span><br><span class="line">        System.out.println(&quot;其他人喂食狗&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建 抽象节点 – 宠物</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Animal &#123;</span><br><span class="line"></span><br><span class="line">    void accept(Person person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建实现Animal接口的 具体节点（元素）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Dog implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Person person) &#123;</span><br><span class="line">        person.feed(this);</span><br><span class="line">        System.out.println(&quot;好好吃，汪汪汪！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 具体节点（元素）角色 -- 宠物猫</span><br><span class="line"> */</span><br><span class="line">class Cat implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Person person) &#123;</span><br><span class="line">        person.feed(this);</span><br><span class="line">        System.out.println(&quot;好好吃，喵喵喵！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.创建实现Animal接口的 具体节点（元素）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Home &#123;</span><br><span class="line">    private List&lt;Animal&gt; nodeList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    void action(Person person) &#123;</span><br><span class="line">        for (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加操作</span><br><span class="line">     *</span><br><span class="line">     * @param animal 动物</span><br><span class="line">     */</span><br><span class="line">    void add(Animal animal) &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.创建客户端，用于测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Home home = new Home();</span><br><span class="line">        home.add(new Dog());</span><br><span class="line">        home.add(new Cat());</span><br><span class="line"></span><br><span class="line">        Owner owner = new Owner();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        Someone someone = new Someone();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.运行结果为：<br>主人喂食狗<br>好好吃，汪汪汪！！！<br>主人喂食猫<br>好好吃，喵喵喵！！！<br>其他人喂食狗<br>好好吃，汪汪汪！！！<br>其他人喂食猫<br>好好吃，喵喵喵！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。</p><blockquote><p>优点</p></blockquote><ul><li>扩展性好： 在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好： 通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</li><li>分离无关行为： 通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>对象结构变化很困难： 不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。</li><li>破坏封装： 访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。</li></ul><blockquote><p>使用场景</p><ul><li>数据结构稳定，作用于数据结构的操作经常变化的时候。</li><li>当一个数据结构中，一些元素类需要负责与其不相关的操作的时候，为了将这些操作分离出去，以减少这些元素类的职责时，可以使用访问者模式。</li><li>有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;访问者模式（Visitor Pattern）&lt;/font&gt;属于&lt;font color=&quot;red&quot;&gt;对象行为型模式&lt;/font&gt;的一种，表示一个作用于其对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之策略模式</title>
    <link href="https://javazhan.com/2018/11/15/2018-11-15-1-java-design-pattern-1/"/>
    <id>https://javazhan.com/2018/11/15/2018-11-15-1-java-design-pattern-1/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2018-11-15T02:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述策略（Strategy）模式的：<br>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><h3 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h3><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p><div align="center"><br><img src="https://javazhan.com/images/disign-pattern/2018-11-15/1.png" alt=""><br></div><br>这个模式涉及到三个角色：<br><strong>环境(Context)角色</strong>：持有一个Strategy的引用。<br><strong>抽象策略(Strategy)角色</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。<br><strong>具体策略(ConcreteStrategy)角色</strong>：包装了相关的算法或行为。<br><br>代码分析<br>环境(Context)角色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">private Strategy strategy;</span><br><span class="line">public Context(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line">public void contextInterface() &#123;</span><br><span class="line">strategy.strategyInterface();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>抽象策略(Strategy)角色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">void strategyInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>具体策略(ConcreteStrategy)角色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategyA implements Strategy</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void strategyInterface() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;do something A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategyB implements Strategy</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void strategyInterface() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;do something B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategyC implements Strategy</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void strategyInterface() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;do something C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>使用场景<br>假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。<br>根据描述，折扣是根据以下的几个算法中的一个进行的：<br>算法一：对初级会员没有折扣。<br>算法二：对中级会员打9折。<br>算法三：对高级会员打8折。<br>使用策略模式来实现的结构图如下：<br><div align="center"><br><img src="https://javazhan.com/images/disign-pattern/2018-11-15/2.png" alt=""><br></div><p>价格类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Price &#123;</span><br><span class="line">private MeberStrategy strategy;</span><br><span class="line">public Price(MeberStrategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line">    public double quote(double bookPrice) &#123;</span><br><span class="line">    return strategy.calsPrice(bookPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象折扣类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MeberStrategy &#123;</span><br><span class="line">double calsPrice(Double bookPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初级会员折扣类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PrimaryMeberStrategy implements MeberStrategy</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public double calsPrice(Double bookPrice) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return bookPrice;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中级会员折扣类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class IntermediateMeberStrategy implements MeberStrategy</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">public double calsPrice(Double bookPrice) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return bookPrice*0.9;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高级会员折扣类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AdvanceMeberStrategy implements MeberStrategy</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public double calsPrice(Double bookPrice) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return bookPrice*0.9;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MeberStrategy strategy = new IntermediateMeberStrategy();</span><br><span class="line">Price price = new Price(strategy);</span><br><span class="line">double bookPrice = price.quote(12);</span><br><span class="line">System.out.println(&quot;图书的最终价格:&quot;+bookPrice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p><h3 id="认识策略模式"><a href="#认识策略模式" class="headerlink" title="认识策略模式"></a>认识策略模式</h3><p><strong>策略模式的重心</strong><br>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。<br><strong>算法的平等性</strong><br>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。<br>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。<br><strong>运行时策略的唯一性</strong><br>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。<br><strong>公有的行为</strong><br>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。<br>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><div align="center"><br><img src="https://javazhan.com/images/disign-pattern/2018-11-15/3.png" alt=""><br></div></p><h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3><ul><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阎宏博士的《JAVA与模式》一书中开头是这样描述策略（Strategy）模式的：&lt;br&gt;策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;/p&gt;

      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之策略模式</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-14-1-java-design-pattern-1/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-14-1-java-design-pattern-1/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-14T10:01:17.591Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java设计模式" scheme="https://javazhan.com/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 三：数组的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-4-java-enum-1/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T09:32:02.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 二：构造器的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-2-java-initial-2/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T07:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Counter()&#123;</span><br><span class="line">int i;</span><br><span class="line">    public Count()&#123;</span><br><span class="line">i = 7;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么i首先会被置0，然后变为7，对于所有基本类型和对象的引用，包括在定义时已经指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前对元素进行初始化————因为初始化早已得到了保证。</p><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。及时变量定义散布于方法定义之间或者之后，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">private Dog dog = new Dog(1);</span><br><span class="line">public Animal() &#123;</span><br><span class="line">new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">private Dog dog1 = new Dog(3);</span><br><span class="line">public void printf() &#123;</span><br><span class="line">new Dog(4);</span><br><span class="line">&#125;</span><br><span class="line">private Dog dog2 = new Dog(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">animal.printf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br>Dog1<br>Dog3<br>Dog5<br>Dog2<br>Dog4</p><p>在Animal类中，故意把几个Dog对象定义散布到各处，以证明它们全都会在构造器或其他方法之前的得到初始化。</p><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null。<br>如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。<br>静态初始化只有在必要时刻才会进行，如果既不创建类也不引用 类.静态成员变量或者静态成员方法，那么静态的成员变量永远不会被创建。<br>初始化的顺序是先静态成员变量后”非静态”成员变量。</p><h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3><p>Java语序将多个静态初始化动作组织成一个特殊的”静态子句”(有时也叫作”静态块”),与其他静态初始化动作一样，这样的静态块也是只执行一次：档首次生成这个类的一个对象时或者首次访问属于那个类的静态数据成员时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">public  void f() &#123;</span><br><span class="line">System.out.println(&quot;print&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">public static Dog dog1;</span><br><span class="line">public static Dog dog2;</span><br><span class="line">static &#123;</span><br><span class="line">dog1 = new Dog(1);</span><br><span class="line">dog2 = new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal.dog1.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为<br>Dog1<br>Dog2<br>print</p><h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">public Dog(int value) &#123;</span><br><span class="line">System.out.println(&quot;Dog&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Animal &#123;</span><br><span class="line">public  Dog dog1;</span><br><span class="line">public  Dog dog2;</span><br><span class="line">public Animal()&#123;</span><br><span class="line">System.out.println(&quot;Initial Animal Constructor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">dog1 = new Dog(1);</span><br><span class="line">dog2 = new Dog(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Animal();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>Dog1<br>Dog2<br>Initial Animal Constructor<br>从输出结果可以看出实例的初始化子句是在构造器之前执行的。</p><p>总结：</p><ul><li>成员变量自动初始化的进行是无法阻止的，它将在构造器被调用之前发生。</li><li>成员变量的定义散布于方法定义之间或者之后，但无论如何它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。</li><li>static关键字不能应用于局部变量，因此它只能作用于域。</li><li>如果一个域是静态的基本类型域，且也没有对它进行初始化，那么他就会获得基本类型的标准初值；如果他是一个对象引用，那么他的默认初始化值就是null，如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。</li><li>初始化的顺序是先静态成员变量后”非静态”成员变量。</li><li>当new一个类时初始化顺序为：静态数据初始化–&gt;非静态的成员变量初始化–&gt;构造器初始化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为变成带来了更大的灵活性，但要牢记：无法阻止自动初始化的进行，他将在构造器被调用之前发生。因此，假如使用下述代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 三：数组的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-3-java-initial-3/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T09:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。</p><h3 id="一位数组的初始化"><a href="#一位数组的初始化" class="headerlink" title="一位数组的初始化"></a>一位数组的初始化</h3><p>一维数组的声明：<br>int[] arr;<br>方括号也可以置于标识符后面：<br>int arr[];<br>两种格式的含义都一样的，没有什么区别，通常C,C++程序猿习惯用第二种写法，不过前一种更合理，java程序猿的话推荐使用第一种写法。<br>一位数组的初始化,如果是int基本类型,并且知道其值和长度时：<br>int[] arr = {1,3,5,7,9}shu<br>int[] arr = new int[]{1,3,5,7,9}<br>上面这个两个数组初始化方法是等价的，没有什么区别<br>如果不知道数组的值和长度时，可以采用以下初始化方法：<br>int[] arr = new int[20]<br>上面的20表示数组初始化的一个大概长度;<br>如果用java.util.Arrays中的toString(arr)方法对数组进行输出，输出结果为：<br>[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的声明：<br>int[][] arr;<br>方括号也可以置于标识符后面：<br>int arr[][];<br>二维数组的初始化，以int基本类型举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//二维数组的初始化第一步</span><br><span class="line">    Integer[][] values = new Integer[3][];//只定义了二维数组的一维长度为3,二维长度可以不定义</span><br><span class="line">    //也可以是Integer[][] values = new Integer[2][4] 这样就定义了数组在二维上的长度为4</span><br><span class="line">    for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">    values[i] = new Integer[4];//定义了二维长度为4</span><br><span class="line">    for(int j=0;j&lt;values[i].length;j++) &#123;</span><br><span class="line">    values[i][j] = new Integer(i+j);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">    for(int j=0;j&lt;values[i].length;j++) &#123;</span><br><span class="line">    System.out.print(values[i][j]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>在可变参数列表中可以放入与该可变的参数类型相同的数组，举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void printObject(Integer...values) &#123;//可变参数</span><br><span class="line">for(Integer value:values) &#123;</span><br><span class="line">System.out.println(value.intValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer[] values = &#123;1,3,5,7,9&#125;;</span><br><span class="line">printObject(values);//可将数组传入到可变参数中</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但需注意的是，传入的数组必须是一个一维数组，如果传入的是二维数组，那么在编译过程中会报错。<br>总结：</p><ul><li>一维数组初始化有三种形式<br>int[] arr = {1,3,5,7,9};<br>int[] arr = new int[]{1,3,5,7,9};<br>int[] arr = new int[20];</li><li>二维数组初始化有两种方式<br>int[][] arr = new int[3][4];<br>int[][] arr = new int[3][];//二维长度在赋值一维时定义长度，例如 arr[0] = new int[4]此时定义二维长度为4</li><li>可变参数中可以传入装入的类型与可变参数类型相同的数组，单数组必须是一维数组</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。&lt;/p&gt;
&lt;h3 id=&quot;一位数组的初始化&quot;&gt;&lt;a href=&quot;#一位数组的初始化&quot; class=&quot;headerlink&quot; title=&quot;一位数组的初始化&quot;&gt;&lt;/a&gt;一位数组的初始化&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于java的初始化( 一：成员变量的初始化 )</title>
    <link href="https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/"/>
    <id>https://javazhan.com/2018/11/13/2018-11-13-1-java-initial-1/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T03:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于成员变量的初始化"><a href="#关于成员变量的初始化" class="headerlink" title="关于成员变量的初始化"></a>关于成员变量的初始化</h3><p>Java会尽力保证:所有变量在使用前都能得到恰当的初始化。<br>如果是成员变量是基本类型，类的每个基本类型的成员变量保证都会有一个初始值，如果成员变量是一个非基本类型，那么它将被初始化成一个特殊值null。下面的程序可以验证这种情况，Dog是一个注意他们的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVars()&#123;</span><br><span class="line">private boolean t;</span><br><span class="line">private char c;</span><br><span class="line">private byte b;</span><br><span class="line">private short s;</span><br><span class="line">private int i;</span><br><span class="line">private long l;</span><br><span class="line">private float f;</span><br><span class="line">private double d;</span><br><span class="line">private String st;</span><br><span class="line">public void printVars()&#123;</span><br><span class="line">    System.out.println(&quot;输出结果为:&quot;);</span><br><span class="line">    System.out.println(&quot;boolean--&gt;&quot;+t);</span><br><span class="line">    System.out.println(&quot;char--&gt;&quot;+c);</span><br><span class="line">    System.out.println(&quot;byte--&gt;&quot;+b);</span><br><span class="line">    System.out.println(&quot;short--&gt;&quot;+s);</span><br><span class="line">    System.out.println(&quot;int--&gt;&quot;+i);</span><br><span class="line">    System.out.println(&quot;long--&gt;&quot;+l);</span><br><span class="line">    System.out.println(&quot;float--&gt;&quot;+f);</span><br><span class="line">    System.out.println(&quot;double--&gt;&quot;+d);</span><br><span class="line">    System.out.println(&quot;String--&gt;&quot;+st);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为:<br>boolean–&gt;false;<br>char–&gt;<br>byte–&gt;0<br>short–&gt;0<br>int–&gt;0<br>long–&gt;0<br>float–&gt;0.0<br>double–&gt;0.0<br>String–&gt;null<br>可见尽管是基本类型的数据成员的初始值没有给出，但他们确实有值(char值为0,所以为空白)，你可以直接使用这些基本类型的成员变量，而非基本类型的成员变量初始值为null,你必须重新new它才可以使用，这样至少不会冒”未初始化变量”的风险了。</p><p>指定初始化<br>如果你想为某个变量赋初始值，该怎么做呢？有一种很直接的办法，就是在定义类变量的地方直接为其赋值。以下代码片段修改了InitialVars类成员变量的定义，直接提供了初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsOne()&#123;</span><br><span class="line">private boolean t = true;</span><br><span class="line">private char c = &apos;x&apos;;</span><br><span class="line">private byte b = 47;</span><br><span class="line">private short s = 0xff;</span><br><span class="line">private int i = 999;</span><br><span class="line">private long l = 1;</span><br><span class="line">private float f = 3.14f;</span><br><span class="line">private double d = 3.1415936;</span><br><span class="line">private String st = new String();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你还可以通过调用方法来初始化成员变量,举个简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsTwo()&#123;</span><br><span class="line">    private int i = initialInt();</span><br><span class="line">    public int initialInt()&#123;</span><br><span class="line">    return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时调用的方法中还可以是参数，但是这些参数必须是初始化后的，举个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsThree()&#123;</span><br><span class="line">    private int j = 3;</span><br><span class="line">private int i = initialInt(j);</span><br><span class="line">    public int initialInt(int vlaue)&#123;</span><br><span class="line">    return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这样是可以的，但是像下面这样就不可以了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InitialVarsFour()&#123;</span><br><span class="line">    private int i = initialInt(j);</span><br><span class="line">    private int j = 3;</span><br><span class="line">    public int initialInt(int vlaue)&#123;</span><br><span class="line">    return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时初始化i的时候j还没有被初始化，所以编译会报错。<br>显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以编译器恰当的对”向前引用”发出了警告。</p><p>对于方法中的局部变量,Java以编译时错误的形式来贯彻这种保证。所以如果写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为你只是声明了i，并没有对i进行初始化，所以在编译时会报错。</p><p>总结：</p><ul><li>对于是基本类型的成员变量如果你只是声明了，没有进行初始化，那么 JVM会自动帮你进行初始化一个值，你可以直接操作这些基本类型的成员变量。</li><li>对于非基本类型的成员变量，如果没有声明那么JVM会初始化为一个特殊值null,你不能直接使用它，必须要new后才能使用它。</li><li>成员变量的初始化顺序就是他们在类中的顺序。</li><li>对于初始化成员变量你可以直接在定义变量的地方进行赋值，也可以通过方法对他们进行赋值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于成员变量的初始化&quot;&gt;&lt;a href=&quot;#关于成员变量的初始化&quot; class=&quot;headerlink&quot; title=&quot;关于成员变量的初始化&quot;&gt;&lt;/a&gt;关于成员变量的初始化&lt;/h3&gt;&lt;p&gt;Java会尽力保证:所有变量在使用前都能得到恰当的初始化。&lt;br&gt;如果是成员
      
    
    </summary>
    
      <category term="后端" scheme="https://javazhan.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java基础" scheme="https://javazhan.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建之HEXO环境安装</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-1-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-1-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T09:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装Git-Bash"><a href="#1-安装Git-Bash" class="headerlink" title="1.安装Git Bash"></a>1.安装Git Bash</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ol><li><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：双击下载好的exe文件，一路next就好啦</li><li>安装好后，打开gitbash，查看版本：用命令 <code>git version</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/0.png" alt=""><h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h3>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧。</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 <code>win + r</code> 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：用命令 <code>node -v</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/1.png" alt=""><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3>看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。</li><li>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo</li><li>安装完成后，查看版本：用命令 <code>hexo -v</code><br><img src="https://javazhan.com/images/hexo/2018-11-12/2.png" alt=""></li><li>初始化命令：<code>hexo init</code> ，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="https://javazhan.com/images/hexo/2018-11-12/3.png" alt=""></li><li>解释一下</li></ol><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息<h3 id="4-创建github-Reponsitory"><a href="#4-创建github-Reponsitory" class="headerlink" title="4.创建github Reponsitory"></a>4.创建github Reponsitory</h3></li></ul><ol><li>首先,创建一个reponsitory如下图:<br><img src="https://javazhan.com/images/hexo/2018-11-12/4.png" alt=""><br>注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README<br><img src="https://javazhan.com/images/hexo/2018-11-12/5.png" alt=""><h3 id="5-配置一下gitbash和github的通信协议"><a href="#5-配置一下gitbash和github的通信协议" class="headerlink" title="5.配置一下gitbash和github的通信协议"></a>5.配置一下gitbash和github的通信协议</h3></li><li>首先打开刚刚安装好的gitbash,界面如下:<br><img src="https://javazhan.com/images/hexo/2018-11-12/6.png" alt=""></li><li>配置gitbash和github的通信协议<br>先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。<br><img src="https://javazhan.com/images/hexo/2018-11-12/6.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装Git-Bash&quot;&gt;&lt;a href=&quot;#1-安装Git-Bash&quot; class=&quot;headerlink&quot; title=&quot;1.安装Git Bash&quot;&gt;&lt;/a&gt;1.安装Git Bash&lt;/h3&gt;&lt;p&gt;我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建(三：在github上部署hexo主题)</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-3-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-3-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T12:26:27.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="寻找主题"><a href="#寻找主题" class="headerlink" title="寻找主题"></a>寻找主题</h3><ol><li>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网主题页</a>上去寻找自己想要的那种风格的hexo主题,每个主题作者都会有在github上的链接,一般链接会放在About页中,这里我以MiHo主题进行讲解。<br>点击About:<br><img src="https://javazhan.com/images/hexo/2018-11-12/24.png" alt=""><br>找到github链接,点击该链接:<br><img src="https://javazhan.com/images/hexo/2018-11-12/25.png" alt=""><br>在跳转页面的overview中可以看到有hexo-theme-miho,点击hexo-theme-miho<br><img src="https://javazhan.com/images/hexo/2018-11-12/26.png" alt=""><br>点解clone or download,让后将网址复制下来:<br><img src="https://javazhan.com/images/hexo/2018-11-12/27.png" alt=""><br>打开gitbash进入到hexo初始化的那个blog页面执行<code>git clone 复制的网址 themes/小写主题名称</code>,然后回车执行命令,执行命令完,你会在blog中themes文件中发现多了一个小写主题名称(我这里是miho)的文件夹,这样就把复制的主题保存到了themes中。<br><img src="https://javazhan.com/images/hexo/2018-11-12/28.png" alt=""><br>接下来就是调整themes中_config.yml中的一些配置<br>这些都做完了，接下来应该怎么办呢？<br>接下来就是将本地的静态博客部署到gitHub上，要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件，可以实现如下命令：</li></ol><ul><li>npm install hexo -server –save</li><li>npm install hexo-deployer-git –save<br>编辑全局 hexo 的配置文件：_config.yml，这块可以参照网上的。</li><li>编辑全局配置后我们需要重新部署：</li><li>先清除掉已经生成的旧文件：hexo clean</li><li>再生成一次静态文件：hexo generate</li><li>在本地预览下：hexo server本地没问题之后，访问<a href="http://localhost:4000,如果成功了,Ctrl" target="_blank" rel="noopener">http://localhost:4000,如果成功了,Ctrl</a> + C 停掉本地预览</li><li>使用部署命令部署到 Github 上：hexo deploy,如有弹出如下提示框，请输入：yes<br><img src="https://javazhan.com/images/hexo/2018-11-12/29.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;寻找主题&quot;&gt;&lt;a href=&quot;#寻找主题&quot; class=&quot;headerlink&quot; title=&quot;寻找主题&quot;&gt;&lt;/a&gt;寻找主题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;你可以到&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建(二：Windows下如何使用gitbash管理github)</title>
    <link href="https://javazhan.com/2018/11/12/2018-11-12-2-hexo/"/>
    <id>https://javazhan.com/2018/11/12/2018-11-12-2-hexo/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T12:44:38.151Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-创建github-Reponsitory"><a href="#4-创建github-Reponsitory" class="headerlink" title="4.创建github Reponsitory"></a>4.创建github Reponsitory</h3><ol><li>首先,创建一个reponsitory如下图:<br><img src="https://javazhan.com/images/hexo/2018-11-12/4.png" alt=""><br>注意下图中的Owner其实就是账户名WangWenHaoBo,Repository name中一定要符合 账户名.github.io，否则无效,另外还要记住勾选Initialize this repository with a README<br><img src="https://javazhan.com/images/hexo/2018-11-12/5.png" alt=""><h3 id="5-配置一下gitbash和github的通信协议"><a href="#5-配置一下gitbash和github的通信协议" class="headerlink" title="5.配置一下gitbash和github的通信协议"></a>5.配置一下gitbash和github的通信协议</h3></li><li>首先打开刚刚安装好的gitbash,界面如下:<br><img src="https://javazhan.com/images/hexo/2018-11-12/6.png" alt=""></li><li>配置gitbash和github的通信协议<br>先输入ssh-keygen –t rsa –C “邮箱地址” 然后一直按回车回车回车回车。。。。箭头指向的邮箱填写我当时填的是和github上写的邮箱一致。<br><img src="https://javazhan.com/images/hexo/2018-11-12/7.png" alt=""></li><li>然后你就可以根据上图提示信息打开文件目录，找到那个文件<br><img src="https://javazhan.com/images/hexo/2018-11-12/8.png" alt=""></li><li>用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。用文本方式打开.pub文件。直接全选复制。重要的事情说三遍。<br>然后打开github自己的主页Settings-&gt;SSH-&gt;newSSHkey<br>不懂看下面的图：<br><img src="https://javazhan.com/images/hexo/2018-11-12/9.png" alt=""></li></ol><p><img src="https://javazhan.com/images/hexo/2018-11-12/10.png" alt=""></p><p><img src="https://javazhan.com/images/hexo/2018-11-12/11.png" alt=""><br>刚刚全选复制的密钥就复制到Key哪里，title随便起。<br><img src="https://javazhan.com/images/hexo/2018-11-12/12.png" alt=""><br>接下来要验证设置！<br>输入命令：ssh –T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，问你yes or no，就输入yes，回车完事<br><img src="https://javazhan.com/images/hexo/2018-11-12/13.png" alt=""><br>配置gitbash的用户名和邮箱：<br>git config –-global user.name “用户名”<br>git config –-global user.email “邮箱”<br>用户名邮箱，用你github上的用户名和邮箱。 </p><h3 id="将你刚刚在github上创建的project和本地联系起来。"><a href="#将你刚刚在github上创建的project和本地联系起来。" class="headerlink" title="将你刚刚在github上创建的project和本地联系起来。"></a>将你刚刚在github上创建的project和本地联系起来。</h3><ol><li>大致说下大概先，就是先在本地找个空的文件夹，然后用gitbash初始化一下这个文件夹的信息，使他变成一个类似于可以被管理的仓库，然后再从远程仓库github上pull上面的东西下来这个文件夹，然后自己修改好了，再push回去远程github，就这么简单。<br>话不多说看图：<br><img src="https://javazhan.com/images/hexo/2018-11-12/14.png" alt=""><br>我在D盘新建了一个名字为git2的文件夹，空的，啥都没有。<br>然后用gitbash打开这个文件夹：<br>具体命令就是cd 路径<br><img src="https://javazhan.com/images/hexo/2018-11-12/15.png" alt=""><br>接下来就是git init:<br><img src="https://javazhan.com/images/hexo/2018-11-12/16.png" alt=""><br>好了，本地的仓库做好了，是时候把远程仓库的东西拉下来了：<br>命令：git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:你的git<br><img src="https://javazhan.com/images/hexo/2018-11-12/17.png" alt=""></li></ol><p><img src="https://javazhan.com/images/hexo/2018-11-12/18.png" alt=""><br>连接上之后，用pull:<br>命令：<br>git pull <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:你的git<br><img src="https://javazhan.com/images/hexo/2018-11-12/19.png" alt=""><br>我这里显示是Already up-to-date，因为我之前已经pull过一次了，你的可能不一样。然后你会发现<br>你的本地仓库文件多了一个.md文件<br><img src="https://javazhan.com/images/hexo/2018-11-12/21.png" alt=""><br>好了，这时候你要怎么把你想传的东西传到github上？<br>比如我新建一个test文档，里面的内容是11111.自己手动新建的，手动，就是直接新建的小伙子。<br>然后我们需要大概就是三个步骤就可以把这个test文件送到github上，<br>git add-&gt;git commit-&gt;git push<br>/////////////////////////////////////////////////////////<br>完整写法看图：<br>每一个$后面的就是我打的命令，当然git add后面跟一个.代表把所有文件都加进去，单独给出特定的文件名字就加特定的文件。<br><img src="https://javazhan.com/images/hexo/2018-11-12/22.png" alt=""><br>然后你就会发现你的github上就多个了文件了<br><img src="https://javazhan.com/images/hexo/2018-11-12/23.png" alt=""><br>后来你想修改的话，就一样的操作啊，pull下来<br>手动修改，add，commit，push。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-创建github-Reponsitory&quot;&gt;&lt;a href=&quot;#4-创建github-Reponsitory&quot; class=&quot;headerlink&quot; title=&quot;4.创建github Reponsitory&quot;&gt;&lt;/a&gt;4.创建github Reponsito
      
    
    </summary>
    
      <category term="前端" scheme="https://javazhan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://javazhan.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
